# Consolidated source export
# Root: /Users/nitinkalokhe/Ni3/spring_boot_proj/oolshik-backend-otp
# Included: ['.bash', '.bat', '.c', '.cfg', '.cjs', '.conf', '.cpp', '.css', '.dart', '.editorconfig', '.env', '.gitattributes', '.gitignore', '.go', '.gradle', '.groovy', '.h', '.hpp', '.htm', '.html', '.ini', '.java', '.js', '.json', '.jsonc', '.jsx', '.kt', '.kts', '.less', '.lua', '.m', '.md', '.mdx', '.mjs', '.mm', '.php', '.properties', '.proto', '.ps1', '.py', '.rb', '.rs', '.scss', '.sh', '.sql', '.swift', '.ts', '.tsx', '.txt', '.xml', '.yaml', '.yml', '.zsh']
# Excluded dirs: ['.expo', '.git', '.gradle', '.idea', '.next', '.venv', '.vscode', 'Pods', 'android/build', 'build', 'coverage', 'dist', 'ios/build', 'node_modules', 'venv']
# Git ignored entries skipped: 110 (if repo)
# ---



===== BEGIN FILE: flatten_code.py =====
#!/usr/bin/env python3
"""
flatten_code.py â€” Walk a project directory and concatenate selected source files
into a single text document with clear file headers/footers.

NEW: Respects .gitignore WITHOUT extra dependencies by using the local `git` CLI.
- If the directory is a Git repo and `git` is available, ignored files are skipped
  using: git ls-files --ignored --exclude-standard --others -z
- Tracked files are always included (even if patterns match .gitignore).
- If not a Git repo (or git missing), falls back to exclude list only.

Usage examples:
  python flatten_code.py --root . --output project-code.txt
  python flatten_code.py --root /path/to/repo --output all.txt --ext ".js,.ts,.tsx,.java,.kt,.py" --exclude ".git,node_modules,dist,build" --max-bytes 1048576
"""
import argparse, os, sys, subprocess, shutil
from pathlib import Path

DEFAULT_EXTS = [
    ".js",".jsx",".ts",".tsx",".mjs",".cjs",
    ".json",".jsonc",
    ".py",
    ".java",".kt",".kts",".gradle",".groovy",
    ".rb",".go",".php",".swift",".m",".mm",".c",".h",".cpp",".hpp",
    ".rs",".dart",".lua",
    ".xml",".html",".htm",".css",".scss",".less",
    ".yml",".yaml",".ini",".cfg",".conf",".properties",".env",
    ".md",".mdx",".txt",
    ".sh",".bash",".zsh",".ps1",".bat",
    ".sql",".proto",
    ".gitignore",".gitattributes",".editorconfig"
]

DEFAULT_EXCLUDES = [
    ".git","node_modules","dist","build",".next",".expo",".idea",".vscode",
    ".venv","venv","Pods","ios/build","android/build","coverage",".gradle"
]

def should_skip_dir(dirpath, excludes_set):
    parts = Path(dirpath).parts
    for token in excludes_set:
        token_parts = Path(token).parts
        if len(token_parts) > 1:
            if tuple(token_parts) == tuple(parts[-len(token_parts):]):
                return True
        else:
            if token in parts:
                return True
    return False

def get_git_ignored(root: Path):
    """
    Return a set of POSIX-style relative paths that are ignored by git.
    Uses: git ls-files --ignored --exclude-standard --others -z
    Only returns files that are ignored AND untracked; tracked files won't appear here.
    """
    if not (root / ".git").exists():
        return set()
    if shutil.which("git") is None:
        return set()
    try:
        out = subprocess.check_output(
            ["git", "ls-files", "--ignored", "--exclude-standard", "--others", "-z"],
            cwd=str(root)
        )
        items = out.decode("utf-8", errors="replace").split("\x00")
        rels = [i for i in items if i]
        # Normalize to POSIX-style
        return set(Path(r).as_posix() for r in rels)
    except Exception:
        return set()

def iter_files(root, exts_set, excludes_set, max_bytes, ignored_set):
    root = Path(root).resolve()
    for dirpath, dirnames, filenames in os.walk(root):
        # prune disallowed dirs
        pruned = []
        for d in list(dirnames):
            full = Path(dirpath) / d
            if should_skip_dir(full, excludes_set):
                pruned.append(d)
        for d in pruned:
            dirnames.remove(d)

        for name in filenames:
            p = Path(dirpath) / name
            rel_posix = p.resolve().relative_to(root).as_posix()

            # Skip git-ignored files if we have that info
            if rel_posix in ignored_set:
                continue

            if exts_set and p.suffix.lower() not in exts_set and name not in exts_set:
                continue
            try:
                if max_bytes and p.stat().st_size > max_bytes:
                    continue
            except OSError:
                continue
            yield p

def main():
    ap = argparse.ArgumentParser(description="Concatenate source files into a single doc with headers, honoring .gitignore if possible (no extra deps).")
    ap.add_argument("--root", default=".", help="Root directory to scan (default: .)")
    ap.add_argument("--output", default="project-code.txt", help="Output file path")
    ap.add_argument("--ext", default=",".join(DEFAULT_EXTS),
                    help="Comma-separated list of file extensions or exact filenames to include")
    ap.add_argument("--exclude", default=",".join(DEFAULT_EXCLUDES),
                    help="Comma-separated list of directories (or suffix paths) to exclude")
    ap.add_argument("--max-bytes", type=int, default=2*1024*1024,
                    help="Skip files larger than this (default 2 MiB)")
    args = ap.parse_args()

    exts = [e.strip() for e in args.ext.split(",") if e.strip()]
    norm_exts = set()
    for e in exts:
        if e.startswith(".") or "." in e:
            norm_exts.add(e.lower())
        else:
            norm_exts.add("." + e.lower())

    excludes = set([e.strip() for e in args.exclude.split(",") if e.strip()])

    root = Path(args.root).resolve()
    ignored_set = get_git_ignored(root)

    out_path = Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    total_files = 0
    with out_path.open("w", encoding="utf-8", errors="replace") as out:
        out.write("# Consolidated source export\n")
        out.write(f"# Root: {root}\n")
        out.write(f"# Included: {sorted(norm_exts)}\n")
        out.write(f"# Excluded dirs: {sorted(excludes)}\n")
        out.write(f"# Git ignored entries skipped: {len(ignored_set)} (if repo)\n")
        out.write("# ---\n\n")

        for p in iter_files(root, norm_exts, excludes, args.max_bytes, ignored_set):
            rel = p.resolve().relative_to(root)
            try:
                content = p.read_text(encoding="utf-8", errors="replace")
            except Exception:
                continue
            out.write(f"\n\n===== BEGIN FILE: {rel} =====\n")
            out.write(content)
            if not content.endswith("\n"):
                out.write("\n")
            out.write(f"===== END FILE: {rel} =====\n")
            total_files += 1

    print(f"Done. Wrote {total_files} files into {out_path}")

if __name__ == "__main__":
    sys.exit(main())
===== END FILE: flatten_code.py =====


===== BEGIN FILE: pom.xml =====
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>software.amazon.awssdk</groupId>
        <artifactId>bom</artifactId>
        <version>2.25.66</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.2</version>
    <relativePath/>
  </parent>

  <groupId>com.oolshik</groupId>
  <artifactId>oolshik-backend</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>oolshik-backend</name>
  <description>Oolshik Phase 1 backend (OTP-first)</description>

  <properties>
    <java.version>21</java.version>
    <jjwt.version>0.11.5</jjwt.version>
    <springdoc.version>2.6.0</springdoc.version>
    <flyway.version>10.15.0</flyway.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>org.flywaydb</groupId>
      <artifactId>flyway-core</artifactId>
      <version>${flyway.version}</version>
    </dependency>
    <dependency>
      <groupId>org.flywaydb</groupId>
      <artifactId>flyway-database-postgresql</artifactId>
      <version>${flyway.version}</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    <!-- JWT -->
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-api</artifactId>
      <version>${jjwt.version}</version>
    </dependency>
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-impl</artifactId>
      <version>${jjwt.version}</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-jackson</artifactId>
      <version>${jjwt.version}</version>
      <scope>runtime</scope>
    </dependency>

    <!-- Swagger/OpenAPI -->
    <dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
      <version>${springdoc.version}</version>
    </dependency>

    <!-- Test -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>software.amazon.awssdk</groupId>
      <artifactId>s3</artifactId>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration>
          <image>
            <name>oolshik/backend:${project.version}</name>
          </image>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
===== END FILE: pom.xml =====


===== BEGIN FILE: oolshik_backend_project.txt =====
# Consolidated source export
# Root: /Users/nitinkalokhe/Ni3/spring_boot_proj/oolshik-backend-otp
# Included: ['.bash', '.bat', '.c', '.cfg', '.cjs', '.conf', '.cpp', '.css', '.dart', '.editorconfig', '.env', '.gitattributes', '.gitignore', '.go', '.gradle', '.groovy', '.h', '.hpp', '.htm', '.html', '.ini', '.java', '.js', '.json', '.jsonc', '.jsx', '.kt', '.kts', '.less', '.lua', '.m', '.md', '.mdx', '.mjs', '.mm', '.php', '.properties', '.proto', '.ps1', '.py', '.rb', '.rs', '.scss', '.sh', '.sql', '.swift', '.ts', '.tsx', '.txt', '.xml', '.yaml', '.yml', '.zsh']
# Excluded dirs: ['.expo', '.git', '.gradle', '.idea', '.next', '.venv', '.vscode', 'Pods', 'android/build', 'build', 'coverage', 'dist', 'ios/build', 'node_modules', 'venv']
# Git ignored entries skipped: 110 (if repo)
# ---



===== BEGIN FILE: flatten_code.py =====
#!/usr/bin/env python3
"""
flatten_code.py â€” Walk a project directory and concatenate selected source files
into a single text document with clear file headers/footers.

NEW: Respects .gitignore WITHOUT extra dependencies by using the local `git` CLI.
- If the directory is a Git repo and `git` is available, ignored files are skipped
  using: git ls-files --ignored --exclude-standard --others -z
- Tracked files are always included (even if patterns match .gitignore).
- If not a Git repo (or git missing), falls back to exclude list only.

Usage examples:
  python flatten_code.py --root . --output project-code.txt
  python flatten_code.py --root /path/to/repo --output all.txt --ext ".js,.ts,.tsx,.java,.kt,.py" --exclude ".git,node_modules,dist,build" --max-bytes 1048576
"""
import argparse, os, sys, subprocess, shutil
from pathlib import Path

DEFAULT_EXTS = [
    ".js",".jsx",".ts",".tsx",".mjs",".cjs",
    ".json",".jsonc",
    ".py",
    ".java",".kt",".kts",".gradle",".groovy",
    ".rb",".go",".php",".swift",".m",".mm",".c",".h",".cpp",".hpp",
    ".rs",".dart",".lua",
    ".xml",".html",".htm",".css",".scss",".less",
    ".yml",".yaml",".ini",".cfg",".conf",".properties",".env",
    ".md",".mdx",".txt",
    ".sh",".bash",".zsh",".ps1",".bat",
    ".sql",".proto",
    ".gitignore",".gitattributes",".editorconfig"
]

DEFAULT_EXCLUDES = [
    ".git","node_modules","dist","build",".next",".expo",".idea",".vscode",
    ".venv","venv","Pods","ios/build","android/build","coverage",".gradle"
]

def should_skip_dir(dirpath, excludes_set):
    parts = Path(dirpath).parts
    for token in excludes_set:
        token_parts = Path(token).parts
        if len(token_parts) > 1:
            if tuple(token_parts) == tuple(parts[-len(token_parts):]):
                return True
        else:
            if token in parts:
                return True
    return False

def get_git_ignored(root: Path):
    """
    Return a set of POSIX-style relative paths that are ignored by git.
    Uses: git ls-files --ignored --exclude-standard --others -z
    Only returns files that are ignored AND untracked; tracked files won't appear here.
    """
    if not (root / ".git").exists():
        return set()
    if shutil.which("git") is None:
        return set()
    try:
        out = subprocess.check_output(
            ["git", "ls-files", "--ignored", "--exclude-standard", "--others", "-z"],
            cwd=str(root)
        )
        items = out.decode("utf-8", errors="replace").split("\x00")
        rels = [i for i in items if i]
        # Normalize to POSIX-style
        return set(Path(r).as_posix() for r in rels)
    except Exception:
        return set()

def iter_files(root, exts_set, excludes_set, max_bytes, ignored_set):
    root = Path(root).resolve()
    for dirpath, dirnames, filenames in os.walk(root):
        # prune disallowed dirs
        pruned = []
        for d in list(dirnames):
            full = Path(dirpath) / d
            if should_skip_dir(full, excludes_set):
                pruned.append(d)
        for d in pruned:
            dirnames.remove(d)

        for name in filenames:
            p = Path(dirpath) / name
            rel_posix = p.resolve().relative_to(root).as_posix()

            # Skip git-ignored files if we have that info
            if rel_posix in ignored_set:
                continue

            if exts_set and p.suffix.lower() not in exts_set and name not in exts_set:
                continue
            try:
                if max_bytes and p.stat().st_size > max_bytes:
                    continue
            except OSError:
                continue
            yield p

def main():
    ap = argparse.ArgumentParser(description="Concatenate source files into a single doc with headers, honoring .gitignore if possible (no extra deps).")
    ap.add_argument("--root", default=".", help="Root directory to scan (default: .)")
    ap.add_argument("--output", default="project-code.txt", help="Output file path")
    ap.add_argument("--ext", default=",".join(DEFAULT_EXTS),
                    help="Comma-separated list of file extensions or exact filenames to include")
    ap.add_argument("--exclude", default=",".join(DEFAULT_EXCLUDES),
                    help="Comma-separated list of directories (or suffix paths) to exclude")
    ap.add_argument("--max-bytes", type=int, default=2*1024*1024,
                    help="Skip files larger than this (default 2 MiB)")
    args = ap.parse_args()

    exts = [e.strip() for e in args.ext.split(",") if e.strip()]
    norm_exts = set()
    for e in exts:
        if e.startswith(".") or "." in e:
            norm_exts.add(e.lower())
        else:
            norm_exts.add("." + e.lower())

    excludes = set([e.strip() for e in args.exclude.split(",") if e.strip()])

    root = Path(args.root).resolve()
    ignored_set = get_git_ignored(root)

    out_path = Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    total_files = 0
    with out_path.open("w", encoding="utf-8", errors="replace") as out:
        out.write("# Consolidated source export\n")
        out.write(f"# Root: {root}\n")
        out.write(f"# Included: {sorted(norm_exts)}\n")
        out.write(f"# Excluded dirs: {sorted(excludes)}\n")
        out.write(f"# Git ignored entries skipped: {len(ignored_set)} (if repo)\n")
        out.write("# ---\n\n")

        for p in iter_files(root, norm_exts, excludes, args.max_bytes, ignored_set):
            rel = p.resolve().relative_to(root)
            try:
                content = p.read_text(encoding="utf-8", errors="replace")
            except Exception:
                continue
            out.write(f"\n\n===== BEGIN FILE: {rel} =====\n")
            out.write(content)
            if not content.endswith("\n"):
                out.write("\n")
            out.write(f"===== END FILE: {rel} =====\n")
            total_files += 1

    print(f"Done. Wrote {total_files} files into {out_path}")

if __name__ == "__main__":
    sys.exit(main())
===== END FILE: flatten_code.py =====


===== BEGIN FILE: pom.xml =====
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>software.amazon.awssdk</groupId>
        <artifactId>bom</artifactId>
        <version>2.25.66</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.2</version>
    <relativePath/>
  </parent>

  <groupId>com.oolshik</groupId>
  <artifactId>oolshik-backend</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>oolshik-backend</name>
  <description>Oolshik Phase 1 backend (OTP-first)</description>

  <properties>
    <java.version>21</java.version>
    <jjwt.version>0.11.5</jjwt.version>
    <springdoc.version>2.6.0</springdoc.version>
    <flyway.version>10.15.0</flyway.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>org.flywaydb</groupId>
      <artifactId>flyway-core</artifactId>
      <version>${flyway.version}</version>
    </dependency>
    <dependency>
      <groupId>org.flywaydb</groupId>
      <artifactId>flyway-database-postgresql</artifactId>
      <version>${flyway.version}</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    <!-- JWT -->
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-api</artifactId>
      <version>${jjwt.version}</version>
    </dependency>
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-impl</artifactId>
      <version>${jjwt.version}</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-jackson</artifactId>
      <version>${jjwt.version}</version>
      <scope>runtime</scope>
    </dependency>

    <!-- Swagger/OpenAPI -->
    <dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
      <version>${springdoc.version}</version>
    </dependency>

    <!-- Test -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>software.amazon.awssdk</groupId>
      <artifactId>s3</artifactId>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration>
          <image>
            <name>oolshik/backend:${project.version}</name>
          </image>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
===== END FILE: oolshik_backend_project.txt =====


===== BEGIN FILE: README.md =====
# Oolshik Backend â€” Phase 1 (OTP-first Auth) â€” Spring Boot 3, Java 21

A clean, extensible backend for **Oolshik Phase 1** with **mobile number + OTP login** as primary auth flow and **optional email** capture. Structured for easy extension into next phases.

## Highlights

- **OTP-first auth** (SMS). Email is optional during OTP verify or later via profile update
- **JWT** access & refresh tokens
- **Users & Roles**: NETA, KARYAKARTA, ADMIN
- **Help Requests**: create, nearby search, accept, complete, cancel
- **PostgreSQL + Flyway** schema migrations
- **Swagger/OpenAPI** docs
- **Docker compose** for 1-command local bring-up
- **Clean structure**: domain, entity, repo, service, web, security, util

## Quick Start

### A) Docker (recommended)

```bash
docker compose build api
docker compose up -d api
docker compose logs -f api
docker exec -it postgres psql -U oolshik -d oolshik
docker exec -it oolshik-backend-otp-api-1 sh -lc 'ls -R ./data/audio || ls -R /data/audio'
```

- API: http://localhost:8080
- Swagger: http://localhost:8080/swagger-ui/index.html
- Dev mode returns OTP code in response payload (for easy mobile integration/testing).

### B) Local (no Docker)

1. Start PostgreSQL and create DB `oolshik` (user/pass `oolshik`), or set env vars below.
2. Run:

```bash
JWT_SECRET=devsecret_at_least_32_chars_long_123456 ADMIN_EMAIL=admin@oolshik.app ADMIN_PASSWORD=Admin@123 SPRING_PROFILES_ACTIVE=dev ./mvnw spring-boot:run
```

## API (Phase 1)

### Auth (OTP-first)

- `POST /api/auth/otp/request`
  ```json
  { "phone": "+919876543210" }
  ```
  Dev mode response includes `"devCode"`.
- `POST /api/auth/otp/verify`
  ```json
  {
    "phone": "+919876543210",
    "code": "123456",
    "displayName": "Nitin",
    "email": "n@example.com"
  }
  ```
  Returns `{ "accessToken": "...", "refreshToken": "..." }`. Creates the user if needed and stores optional fields.
- `POST /api/auth/refresh` â†’ `{ "accessToken": "..." }`
- `GET  /api/auth/me` â†’ profile
- `PUT  /api/auth/me` â†’ update `displayName`, `languages`, `email`
- `POST /api/auth/login` (email+password; **admin only** for ops)

### Help Requests

- `POST /api/requests`
- `GET  /api/requests/nearby?lat=..&lon=..&radiusMeters=1000`
- `POST /api/requests/{id}/accept`
- `POST /api/requests/{id}/complete`
- `POST /api/requests/{id}/cancel`

## Configuration

Environment variables (defaults in `application.yml`):

- `DB_HOST=localhost`, `DB_PORT=5432`, `DB_NAME=oolshik`, `DB_USER=oolshik`, `DB_PASSWORD=oolshik`
- `JWT_SECRET` (**required**; 32+ chars recommended)
- `SPRING_PROFILES_ACTIVE=dev`
- `app.otp.ttlSeconds=300`, `app.otp.cooldownSeconds=30`, `app.otp.maxAttempts=5`

**Admin seeding (ops):**

```
ADMIN_EMAIL=admin@oolshik.app
ADMIN_PASSWORD=Admin@123
```

Seeds an admin with placeholder phone `+910000000000`. Admin can login via `/api/auth/login`.

## Design Notes

- **OTP codes** are stored **hashed** (BCrypt), with TTL, resend cooldown, and attempt throttling.
- **Phone normalization**: simple E.164-ish helper defaults to +91 when obvious (10-digit input). Replace with libphonenumber later if needed.
- **SMS sending**: pluggable `SmsSender` interface; dev profile logs messages; add Twilio/SNS later.
- **Nearby search**: simple equirectangular distance in SQL; swap to PostGIS later without changing controller/service contracts.
- **Clean layering**: Controllers â†’ Services â†’ Repos â†’ Entities; DTOs for requests/responses; exception handler for neat API errors.

## Build & Run

```bash
./mvnw -q -DskipTests package
java -jar target/oolshik-backend-0.0.1-SNAPSHOT.jar
```

---

This codebase is intentionally minimal yet production-leaning so you can extend it in next phases (chat, media, ratings, categories, payments) without refactoring auth or user domains.
===== END FILE: README.md =====


===== BEGIN FILE: .gitignore =====
target/
.idea/
*.iml
.mvn/wrapper/maven-wrapper.jar
.DS_Store
.env
===== END FILE: .gitignore =====


===== BEGIN FILE: docker-compose.yml =====
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: oolshik
      POSTGRES_PASSWORD: oolshik
      POSTGRES_DB: oolshik
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER"]
      interval: 5s
      timeout: 5s
      retries: 10
  api:
    build: .
    environment:
      DB_HOST: db
      DB_PORT: 5432
      DB_NAME: oolshik
      DB_USER: oolshik
      DB_PASSWORD: oolshik
      JWT_SECRET: devsecret_change_me_at_least_32_chars_long_123456
      ADMIN_EMAIL: admin@oolshik.app
      ADMIN_PASSWORD: Admin@123
      SPRING_PROFILES_ACTIVE: dev
      # turn ON flyway
      SPRING_FLYWAY_ENABLED: true
      SPRING_FLYWAY_BASELINE_ON_MIGRATE: true
      SPRING_FLYWAY_BASELINE_VERSION: 1
      # hibernate: validate schema only
      SPRING_JPA_HIBERNATE_DDL_AUTO: validate
    ports:
      - "8080:8080"
    depends_on:
      db:
        condition: service_healthy
===== END FILE: docker-compose.yml =====


===== BEGIN FILE: .mvn/wrapper/maven-wrapper.properties =====
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.6/apache-maven-3.9.6-bin.zip
wrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar
===== END FILE: .mvn/wrapper/maven-wrapper.properties =====


===== BEGIN FILE: src/test/java/com/oolshik/backend/SanityTest.java =====
package com.oolshik.backend;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SanityTest {
    @Test
    void contextLoads() {}
}
===== END FILE: src/test/java/com/oolshik/backend/SanityTest.java =====


===== BEGIN FILE: src/main/resources/logback-spring.xml =====
<?xml version="1.0" encoding="UTF-8"?>
<configuration scan="true" scanPeriod="30 seconds">
  <springProperty scope="context" name="APP_NAME" source="spring.application.name" defaultValue="oolshik-backend"/>
  <property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] ${APP_NAME} %X{cid:-no-cid} %logger{36} - %msg%n"/>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
      <pattern>${LOG_PATTERN}</pattern>
    </encoder>
  </appender>

  <!-- Project package log level -->
  <logger name="com.oolshik.backend" level="INFO"/>
  <!-- Optional Hibernate SQL logs -->
  <!-- <logger name="org.hibernate.SQL" level="DEBUG"/> -->
  <!-- <logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE"/> -->

  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
===== END FILE: src/main/resources/logback-spring.xml =====


===== BEGIN FILE: src/main/resources/application.yml =====
spring:
  application:
    name: oolshik-backend
  datasource:
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:oolshik}
    username: ${DB_USER:oolshik}
    password: ${DB_PASSWORD:oolshik}
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        format_sql: true
        jdbc:
          time_zone: UTC
  flyway:
    enabled: true
    locations: classpath:db/migration

  servlet:
    multipart:
      max-file-size: 45MB
      max-request-size: 50MB
server:
  port: 8080

app:
  jwt:
    secret: ${JWT_SECRET:CHANGEME_DEV_SECRET_32_CHARS_MINIMUM________}
    accessTokenTtlMinutes: 60
    refreshTokenTtlDays: 14
  otp:
    ttlSeconds: 300
    cooldownSeconds: 30
    maxAttempts: 5

logging:
  level:
    org.springframework.security: INFO
    org.hibernate.SQL: DEBUG
    com.oolshik.backend: DEBUG
    org.springframework.web: INFO
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

management:
  endpoints:
    web:
      exposure:
        include: health,info
  endpoint:
    health:
      show-details: never

media:
  storage: local   # local | s3

  local:
    root: ./data/audio

  s3:
    bucket: your-bucket-name
    region: ap-south-1
    prefix: audio/
    # endpoint: http://localhost:9000
    # pathStyleAccessEnabled: true
===== END FILE: src/main/resources/application.yml =====


===== BEGIN FILE: src/main/resources/db/migration/V3__phone_reveal_event_fix.sql =====
-- V3__phone_reveal_event_fix.sql
-- 1) add help_request_id
ALTER TABLE phone_reveal_event ADD COLUMN IF NOT EXISTS help_request_id UUID;

-- 2) backfill help_request_id from the incorrect requester_user_id that currently holds help_request.id
--    and fix requester_user_id to the real user id
UPDATE phone_reveal_event pre
SET help_request_id = pre.requester_user_id
WHERE pre.help_request_id IS NULL;

UPDATE phone_reveal_event pre
SET requester_user_id = hr.requester_id
    FROM help_request hr
WHERE pre.help_request_id = hr.id
  AND pre.requester_user_id <> hr.requester_id;

-- 3) defaults
ALTER TABLE phone_reveal_event
    ALTER COLUMN reveal_count SET DEFAULT 0;

-- 4) uniqueness per (help_request_id, target_user_id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes
    WHERE schemaname = 'public'
      AND indexname = 'uk_reveal_req_target'
  ) THEN
CREATE UNIQUE INDEX uk_reveal_req_target
    ON phone_reveal_event (help_request_id, target_user_id);
END IF;
END$$;
===== END FILE: src/main/resources/db/migration/V3__phone_reveal_event_fix.sql =====


===== BEGIN FILE: src/main/resources/db/migration/V5__audio_tables.sql =====
-- V30__audio_tables.sql
CREATE TABLE IF NOT EXISTS audio_files (
    id UUID PRIMARY KEY,
    owner_user_id VARCHAR(100) NOT NULL,
    filename VARCHAR(255) NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    size_bytes BIGINT NOT NULL,
    storage_key VARCHAR(500) NOT NULL,
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    duration_ms BIGINT NULL,
    sample_rate INTEGER NULL,
    request_id VARCHAR(100) NULL
);
===== END FILE: src/main/resources/db/migration/V5__audio_tables.sql =====


===== BEGIN FILE: src/main/resources/db/migration/V1__init.sql =====
CREATE TABLE IF NOT EXISTS app_user (
    id UUID PRIMARY KEY,
    phone_number VARCHAR(32) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE,
    password_hash VARCHAR(255),
    display_name VARCHAR(255),
    roles TEXT NOT NULL,
    languages TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS help_request (
    id UUID PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    latitude DOUBLE PRECISION NOT NULL,
    longitude DOUBLE PRECISION NOT NULL,
    radius_meters INTEGER NOT NULL,
    status VARCHAR(32) NOT NULL,
    requester_id UUID NOT NULL REFERENCES app_user(id),
    helper_id UUID REFERENCES app_user(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS otp_code (
    id UUID PRIMARY KEY,
    phone_number VARCHAR(32) NOT NULL,
    code_hash VARCHAR(255) NOT NULL,
    purpose VARCHAR(32) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    consumed_at TIMESTAMP WITH TIME ZONE,
    attempt_count INTEGER NOT NULL DEFAULT 0,
    resend_count INTEGER NOT NULL DEFAULT 0,
    last_sent_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_help_request_status ON help_request(status);
CREATE INDEX IF NOT EXISTS idx_help_request_geo ON help_request(latitude, longitude);
CREATE INDEX IF NOT EXISTS idx_otp_phone ON otp_code(phone_number);
===== END FILE: src/main/resources/db/migration/V1__init.sql =====


===== BEGIN FILE: src/main/resources/db/migration/V4__report_event.sql =====
-- Ensure UUID generator exists (Postgres)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Moderation reports table
CREATE TABLE IF NOT EXISTS report_event (
                                            id                 UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    reporter_user_id   UUID NOT NULL REFERENCES app_user(id),
    target_user_id     UUID NULL REFERENCES app_user(id),
    help_request_id    UUID NULL REFERENCES help_request(id),
    reason             TEXT NOT NULL CHECK (reason IN ('SPAM','INAPPROPRIATE','UNSAFE','OTHER')),
    details            TEXT NULL,
    created_at         TIMESTAMPTZ NOT NULL DEFAULT now()
    );

CREATE INDEX IF NOT EXISTS idx_report_event_help_request_id ON report_event(help_request_id);
CREATE INDEX IF NOT EXISTS idx_report_event_target_user_id ON report_event(target_user_id);
CREATE INDEX IF NOT EXISTS idx_report_event_created_at ON report_event(created_at DESC);
===== END FILE: src/main/resources/db/migration/V4__report_event.sql =====


===== BEGIN FILE: src/main/resources/db/migration/V2__phone_reveal_event.sql =====

-- V2__phone_reveal_event.sql
CREATE TABLE phone_reveal_event (
                                    id UUID PRIMARY KEY,
                                    requester_user_id UUID NOT NULL,   -- ðŸ‘ˆ Add this column
                                    target_user_id UUID NOT NULL,
                                    phone_number VARCHAR(20) NOT NULL,
                                    revealed_at TIMESTAMP WITHOUT TIME ZONE DEFAULT now(),
                                    reveal_count INT DEFAULT 0
);

-- Optional: index for analytics
CREATE INDEX idx_phone_reveal_event_requester ON phone_reveal_event(requester_user_id);
CREATE INDEX idx_phone_reveal_event_target ON phone_reveal_event(target_user_id);
===== END FILE: src/main/resources/db/migration/V2__phone_reveal_event.sql =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/OolshikApplication.java =====
package com.oolshik.backend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class OolshikApplication {
    public static void main(String[] args) {
        SpringApplication.run(OolshikApplication.class, args);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/OolshikApplication.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/util/PhoneUtil.java =====
package com.oolshik.backend.util;

public class PhoneUtil {
    // Normalize to E.164-like format: retain + and digits, strip spaces/dashes.
    public static String normalize(String raw) {
    if (raw == null) return null;
    String s = raw.trim().replace(" ", "").replace("-", "");
    if (!s.startsWith("+")) {
        // assume India if 10 digits or starts with 0/91; adapt as needed later
        s = s.replaceFirst("^0+", "");
        if (s.startsWith("91") && s.length() == 12) {
            s = "+" + s;
        } else if (s.length() == 10) {
            s = "+91" + s;
        } else if (s.matches("^\\d{1,15}$")) {
            s = "+" + s;
        }
    }
    return s;
}
}
===== END FILE: src/main/java/com/oolshik/backend/util/PhoneUtil.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/config/OpenApiConfig.java =====
package com.oolshik.backend.config;

import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.OpenAPI;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI api() {
        return new OpenAPI().info(new Info().title("Oolshik API (OTP-first)").version("v1").description("Oolshik Phase 1 backend"));
    }
}
===== END FILE: src/main/java/com/oolshik/backend/config/OpenApiConfig.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/config/CommonBeans.java =====
package com.oolshik.backend.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.cors.CorsConfigurationSource;
import java.util.List;

@Configuration
public class CommonBeans {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration cfg = new CorsConfiguration();
        cfg.setAllowedOrigins(List.of("*"));
        cfg.setAllowedMethods(List.of("GET","POST","PUT","DELETE","OPTIONS"));
        cfg.setAllowedHeaders(List.of("Authorization","Content-Type"));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", cfg);
        return source;
    }
}
===== END FILE: src/main/java/com/oolshik/backend/config/CommonBeans.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/config/MediaStorageConfig.java =====
package com.oolshik.backend.config;

import com.oolshik.backend.media.LocalStorageService;
import com.oolshik.backend.media.S3StorageService;
import com.oolshik.backend.media.StorageService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MediaStorageConfig {

    @Bean // name: storageService
    @ConditionalOnProperty(name = "media.storage", havingValue = "local", matchIfMissing = true)
    public StorageService storageServiceLocal(
            @Value("${media.local.root:./data/audio}") String root
    ) throws Exception {
        return new LocalStorageService(root);
    }

    @Bean // name: storageService
    @ConditionalOnProperty(name = "media.storage", havingValue = "s3")
    public StorageService storageServiceS3(
            @Value("${media.s3.bucket}") String bucket,
            @Value("${media.s3.region}") String region,
            @Value("${media.s3.prefix:audio/}") String prefix,
            @Value("${media.s3.endpoint:}") String endpoint,
            @Value("${media.s3.pathStyleAccessEnabled:false}") boolean pathStyle
    ) throws Exception {
        return new S3StorageService(bucket, region, prefix, endpoint, pathStyle);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/config/MediaStorageConfig.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/security/SecurityConfig.java =====
package com.oolshik.backend.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtAuthFilter jwtAuthFilter;
    private final UserDetailsService uds;

    public SecurityConfig(JwtAuthFilter jwtAuthFilter, UserDetailsService uds) {
        this.jwtAuthFilter = jwtAuthFilter;
        this.uds = uds;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable());
        http.authorizeHttpRequests(auth -> auth
            .requestMatchers(
                "/api/auth/**",
                "/v3/api-docs/**",
                "/swagger-ui/**",
                "/swagger-ui.html"
            ).permitAll()
            .requestMatchers(HttpMethod.GET, "/actuator/health").permitAll()
            .anyRequest().authenticated()
        );
        http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        http.cors(org.springframework.security.config.Customizer.withDefaults());
        http.httpBasic(Customizer.withDefaults());
        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(PasswordEncoder passwordEncoder) {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(uds);
        provider.setPasswordEncoder(passwordEncoder);
        return new ProviderManager(provider);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/security/SecurityConfig.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/security/JwtService.java =====
package com.oolshik.backend.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import java.security.Key;
import java.time.Instant;
import java.util.Date;
import java.util.Map;
import java.util.UUID;

@Service
public class JwtService {

    private final Key key;
    private final long accessTtlMinutes;
    private final long refreshTtlDays;

    public JwtService(
            @Value("${app.jwt.secret}") String secret,
            @Value("${app.jwt.accessTokenTtlMinutes}") long accessTtlMinutes,
            @Value("${app.jwt.refreshTokenTtlDays}") long refreshTtlDays
    ) {
        this.key = Keys.hmacShaKeyFor(secret.getBytes());
        this.accessTtlMinutes = accessTtlMinutes;
        this.refreshTtlDays = refreshTtlDays;
    }

    public String generateAccessToken(UUID userId, String phone) {
        Instant now = Instant.now();
        return Jwts.builder()
                .setSubject(userId.toString())
                .setIssuedAt(Date.from(now))
                .setExpiration(Date.from(now.plusSeconds(accessTtlMinutes * 60)))
                .addClaims(Map.of("phone", phone, "typ", "access"))
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();
    }

    public String generateRefreshToken(UUID userId) {
        Instant now = Instant.now();
        return Jwts.builder()
                .setSubject(userId.toString())
                .setIssuedAt(Date.from(now))
                .setExpiration(Date.from(now.plusSeconds(refreshTtlDays * 86400)))
                .addClaims(Map.of("typ", "refresh"))
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();
    }

    public Jws<Claims> parse(String token) {
        return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/security/JwtService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/security/JwtAuthFilter.java =====
package com.oolshik.backend.security;

import io.jsonwebtoken.Claims;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.context.annotation.Lazy;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserDetailsService uds;

    public JwtAuthFilter(JwtService jwtService, @Lazy UserDetailsService uds) {
        this.jwtService = jwtService;
        this.uds = uds;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        String header = request.getHeader("Authorization");
        if (header != null && header.startsWith("Bearer ")) {
            String token = header.substring(7);
            try {
                var jws = jwtService.parse(token);
                Claims c = jws.getBody();
                String phone = c.get("phone", String.class);
                if (phone != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                    UserDetails u = uds.loadUserByUsername(phone);
                    var auth = new UsernamePasswordAuthenticationToken(u, null, u.getAuthorities());
                    auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(auth);
                }
            } catch (Exception ignored) { }
        }
        chain.doFilter(request, response);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/security/JwtAuthFilter.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/entity/HelpRequestEntity.java =====
package com.oolshik.backend.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.UUID;
import com.oolshik.backend.domain.HelpRequestStatus;

@Entity
@Table(name = "help_request")
public class HelpRequestEntity {
    @Id
    private UUID id;

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(nullable = false)
    private double latitude;

    @Column(nullable = false)
    private double longitude;

    @Column(nullable = false, name = "radius_meters")
    private int radiusMeters;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private HelpRequestStatus status;

    @Column(name = "requester_id", nullable = false)
    private UUID requesterId;

    @Transient
    String displayName;

    @Transient
    String phoneNumber;

    @Column(name = "helper_id")
    private UUID helperId;

    @Column(nullable = false)
    private OffsetDateTime createdAt;

    @Column(nullable = false)
    private OffsetDateTime updatedAt;

    @PrePersist
    public void prePersist() {
        if (id == null) id = UUID.randomUUID();
        if (createdAt == null) createdAt = OffsetDateTime.now();
        if (updatedAt == null) updatedAt = createdAt;
        if (status == null) status = HelpRequestStatus.OPEN;
    }

    @PreUpdate
    public void preUpdate() { updatedAt = OffsetDateTime.now(); }

    // getters/setters
    public UUID getId() { return id; }
    public String getTitle() { return title; }
    public String getDescription() { return description; }
    public double getLatitude() { return latitude; }
    public double getLongitude() { return longitude; }
    public int getRadiusMeters() { return radiusMeters; }
    public HelpRequestStatus getStatus() { return status; }
    public UUID getRequesterId() { return requesterId; }
    public String getDisplayName() { return displayName; }
    public String getPhoneNumber() { return phoneNumber; }
    public UUID getHelperId() { return helperId; }
    public OffsetDateTime getCreatedAt() { return createdAt; }
    public OffsetDateTime getUpdatedAt() { return updatedAt; }
    public void setId(UUID id) { this.id = id; }
    public void setTitle(String title) { this.title = title; }
    public void setDescription(String description) { this.description = description; }
    public void setLatitude(double latitude) { this.latitude = latitude; }
    public void setLongitude(double longitude) { this.longitude = longitude; }
    public void setRadiusMeters(int radiusMeters) { this.radiusMeters = radiusMeters; }
    public void setStatus(HelpRequestStatus status) { this.status = status; }
    public void setRequesterId(UUID requesterId) { this.requesterId = requesterId; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    public void setHelperId(UUID helperId) { this.helperId = helperId; }
    public void setCreatedAt(OffsetDateTime createdAt) { this.createdAt = createdAt; }
    public void setUpdatedAt(OffsetDateTime updatedAt) { this.updatedAt = updatedAt; }
}
===== END FILE: src/main/java/com/oolshik/backend/entity/HelpRequestEntity.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/entity/PhoneRevealEventEntity.java =====
package com.oolshik.backend.entity;

import jakarta.persistence.*;
import org.hibernate.annotations.UuidGenerator;

import java.time.Instant;
import java.util.*;

@Entity
@Table(
        name = "phone_reveal_event",
        indexes = {
                @Index(name = "idx_pre_requester", columnList = "requester_user_id"),
                @Index(name = "idx_pre_target", columnList = "target_user_id"),
                @Index(name = "idx_pre_revealed_at", columnList = "revealed_at")
        }
)
public class PhoneRevealEventEntity {

    @Id
    @GeneratedValue
    @UuidGenerator(style = UuidGenerator.Style.RANDOM)
    @Column(name = "id", nullable = false, updatable = false, columnDefinition = "uuid")
    private UUID id;

    /** The user who clicked to reveal the phone number */
    @Column(name = "requester_user_id", nullable = false)
    private UUID requesterUserId;

    /** The owner of the phone number being revealed */
    @Column(name = "target_user_id", nullable = false)
    private UUID targetUserId;

    /** The phone number that was revealed (store the exact number shown) */
    @Column(name = "phone_number", nullable = false, length = 20)
    private String phoneNumber;

    /** When the reveal happened */
    @Column(name = "revealed_at", nullable = false)
    private Instant revealedAt;

    /** Optional counter if you choose to increment per target/number */
    @Column(name = "reveal_count", nullable = false)
    private Integer revealCount = 0;

    // ---- Optional read-only associations (handy for joins / projections) ----
    // They are read-only (insertable=false, updatable=false) because we persist via the *_user_id fields.
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "requester_user_id", referencedColumnName = "id", insertable = false, updatable = false)
    private UserEntity requesterUser;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "target_user_id", referencedColumnName = "id", insertable = false, updatable = false)
    private UserEntity targetUser;

    // ---- Constructors ----
    public PhoneRevealEventEntity() {}

    public PhoneRevealEventEntity(UUID requesterUserId, UUID targetUserId, String phoneNumber) {
        this.requesterUserId = requesterUserId;
        this.targetUserId = targetUserId;
        this.phoneNumber = phoneNumber;
    }

    // ---- Lifecycle ----
    @PrePersist
    public void prePersist() {
        if (this.revealedAt == null) {
            this.revealedAt = Instant.now();
        }
        if (this.revealCount == null) {
            this.revealCount = 0;
        }
    }

    // ---- Getters / Setters ----
    public UUID getId() { return id; }

    public UUID getRequesterUserId() { return requesterUserId; }
    public void setRequesterUserId(UUID requesterUserId) { this.requesterUserId = requesterUserId; }

    public UUID getTargetUserId() { return targetUserId; }
    public void setTargetUserId(UUID targetUserId) { this.targetUserId = targetUserId; }

    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }

    public Instant getRevealedAt() { return revealedAt; }
    public void setRevealedAt(Instant revealedAt) { this.revealedAt = revealedAt; }

    public Integer getRevealCount() { return revealCount; }
    public void setRevealCount(Integer revealCount) { this.revealCount = revealCount; }

    public UserEntity getRequesterUser() { return requesterUser; }
    public UserEntity getTargetUser() { return targetUser; }
}
===== END FILE: src/main/java/com/oolshik/backend/entity/PhoneRevealEventEntity.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/entity/UserEntity.java =====
package com.oolshik.backend.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.*;
import com.oolshik.backend.domain.Role;

@Entity
@Table(name = "app_user")
public class UserEntity {
    @Id
    private UUID id;

    @Column(name = "phone_number", nullable = false, unique = true)
    private String phoneNumber;

    @Column(unique = true)
    private String email;

    @Column(name = "password_hash")
    private String passwordHash;

    private String displayName;

    @Column(nullable = false)
    private String roles; // comma-separated

    private String languages;

    @Column(nullable = false)
    private OffsetDateTime createdAt;

    @Column(nullable = false)
    private OffsetDateTime updatedAt;

    @PrePersist
    public void prePersist() {
        if (id == null) id = UUID.randomUUID();
        if (createdAt == null) createdAt = OffsetDateTime.now();
        if (updatedAt == null) updatedAt = createdAt;
        if (roles == null || roles.isBlank()) roles = "NETA";
    }

    @PreUpdate
    public void preUpdate() { updatedAt = OffsetDateTime.now(); }

    public Set<Role> getRoleSet() {
        Set<Role> set = new HashSet<>();
        if (roles == null || roles.isBlank()) return set;
        for (String r : roles.split(",")) {
            try { set.add(Role.valueOf(r.trim())); } catch (Exception ignored) {}
        }
        return set;
    }

    public void setRoleSet(Set<Role> set) {
        this.roles = String.join(",", set.stream().map(Enum::name).toList());
    }

    // getters/setters
    public UUID getId() { return id; }
    public String getPhoneNumber() { return phoneNumber; }
    public String getEmail() { return email; }
    public String getPasswordHash() { return passwordHash; }
    public String getDisplayName() { return displayName; }
    public String getRoles() { return roles; }
    public String getLanguages() { return languages; }
    public OffsetDateTime getCreatedAt() { return createdAt; }
    public OffsetDateTime getUpdatedAt() { return updatedAt; }
    public void setId(UUID id) { this.id = id; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
    public void setEmail(String email) { this.email = email; }
    public void setPasswordHash(String passwordHash) { this.passwordHash = passwordHash; }
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    public void setRoles(String roles) { this.roles = roles; }
    public void setLanguages(String languages) { this.languages = languages; }
    public void setCreatedAt(OffsetDateTime createdAt) { this.createdAt = createdAt; }
    public void setUpdatedAt(OffsetDateTime updatedAt) { this.updatedAt = updatedAt; }
}
===== END FILE: src/main/java/com/oolshik/backend/entity/UserEntity.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/entity/OtpCodeEntity.java =====
package com.oolshik.backend.entity;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.UUID;

@Entity
@Table(name = "otp_code")
public class OtpCodeEntity {
    @Id
    private UUID id;

    @Column(name = "phone_number", nullable = false)
    private String phoneNumber;

    @Column(name = "code_hash", nullable = false)
    private String codeHash;

    @Column(nullable = false)
    private String purpose; // LOGIN

    @Column(name = "expires_at", nullable = false)
    private OffsetDateTime expiresAt;

    @Column(name = "consumed_at")
    private OffsetDateTime consumedAt;

    @Column(name = "attempt_count", nullable = false)
    private int attemptCount;

    @Column(name = "resend_count", nullable = false)
    private int resendCount;

    @Column(name = "last_sent_at", nullable = false)
    private OffsetDateTime lastSentAt;

    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt;

    @PrePersist
    public void prePersist() {
        if (id == null) id = UUID.randomUUID();
        if (createdAt == null) createdAt = OffsetDateTime.now();
        if (lastSentAt == null) lastSentAt = createdAt;
        if (attemptCount < 0) attemptCount = 0;
        if (resendCount < 0) resendCount = 0;
    }

    // getters/setters
    public UUID getId() { return id; }
    public String getPhoneNumber() { return phoneNumber; }
    public String getCodeHash() { return codeHash; }
    public String getPurpose() { return purpose; }
    public OffsetDateTime getExpiresAt() { return expiresAt; }
    public OffsetDateTime getConsumedAt() { return consumedAt; }
    public int getAttemptCount() { return attemptCount; }
    public int getResendCount() { return resendCount; }
    public OffsetDateTime getLastSentAt() { return lastSentAt; }
    public OffsetDateTime getCreatedAt() { return createdAt; }
    public void setId(UUID id) { this.id = id; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
    public void setCodeHash(String codeHash) { this.codeHash = codeHash; }
    public void setPurpose(String purpose) { this.purpose = purpose; }
    public void setExpiresAt(OffsetDateTime expiresAt) { this.expiresAt = expiresAt; }
    public void setConsumedAt(OffsetDateTime consumedAt) { this.consumedAt = consumedAt; }
    public void setAttemptCount(int attemptCount) { this.attemptCount = attemptCount; }
    public void setResendCount(int resendCount) { this.resendCount = resendCount; }
    public void setLastSentAt(OffsetDateTime lastSentAt) { this.lastSentAt = lastSentAt; }
    public void setCreatedAt(OffsetDateTime createdAt) { this.createdAt = createdAt; }
}
===== END FILE: src/main/java/com/oolshik/backend/entity/OtpCodeEntity.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/entity/ReportEventEntity.java =====
package com.oolshik.backend.entity;

import com.oolshik.backend.domain.ReportReason;
import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.UUID;

@Entity
@Table(name = "report_event")
public class ReportEventEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "reporter_user_id", nullable = false)
    private UUID reporterUserId;

    @Column(name = "target_user_id")
    private UUID targetUserId;

    @Column(name = "help_request_id")
    private UUID helpRequestId;

    @Enumerated(EnumType.STRING)
    @Column(name = "reason", nullable = false)
    private ReportReason reason;

    @Column(name = "details")
    private String details;

    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt;

    @PrePersist
    void onCreate() {
        if (createdAt == null) createdAt = OffsetDateTime.now();
    }

    // getters/setters ...
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public UUID getReporterUserId() { return reporterUserId; }
    public void setReporterUserId(UUID reporterUserId) { this.reporterUserId = reporterUserId; }

    public UUID getTargetUserId() { return targetUserId; }
    public void setTargetUserId(UUID targetUserId) { this.targetUserId = targetUserId; }

    public UUID getHelpRequestId() { return helpRequestId; }
    public void setHelpRequestId(UUID helpRequestId) { this.helpRequestId = helpRequestId; }

    public ReportReason getReason() { return reason; }
    public void setReason(ReportReason reason) { this.reason = reason; }

    public String getDetails() { return details; }
    public void setDetails(String details) { this.details = details; }

    public OffsetDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(OffsetDateTime createdAt) { this.createdAt = createdAt; }
}
===== END FILE: src/main/java/com/oolshik/backend/entity/ReportEventEntity.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/GlobalExceptionHandler.java =====
package com.oolshik.backend.web;

import com.oolshik.backend.web.error.ConflictOperationException;
import com.oolshik.backend.web.error.ForbiddenOperationException;
import jakarta.persistence.EntityNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.validation.FieldError;
import org.springframework.web.ErrorResponseException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.server.ResponseStatusException;

@ControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    private record ApiError(String cid, String error, String message) {
    }

    private String cid() {
        return MDC.get("cid");
    }

    /* ---------------------------
     *  400 â€“ Validation / Bad input
     * --------------------------- */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiError> handleValidation(MethodArgumentNotValidException ex) {
        String msg = ex.getBindingResult().getAllErrors().stream()
                .findFirst()
                .map(err -> {
                    if (err instanceof FieldError fe) {
                        return fe.getField() + ": " + fe.getDefaultMessage();
                    }
                    return err.getDefaultMessage();
                })
                .orElse("Validation failed");
        log.warn("[{}] 400 validation_error: {}", cid(), msg);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ApiError(cid(), "validation_error", msg));
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiError> handleIllegalArgument(IllegalArgumentException ex) {
        // Bad client input, not a server error
        log.warn("[{}] 400 invalid_argument: {}", cid(), ex.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ApiError(cid(), "invalid_argument", ex.getMessage()));
    }

    /* ---------------------------
     *  403 â€“ Forbidden
     * --------------------------- */
    @ExceptionHandler({ForbiddenOperationException.class, AccessDeniedException.class})
    public ResponseEntity<ApiError> handleForbidden(RuntimeException ex) {
        log.warn("[{}] 403 forbidden: {}", cid(), ex.getMessage());
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(new ApiError(cid(), "forbidden", ex.getMessage()));
    }

    /* ---------------------------
     *  404 â€“ Not found
     * --------------------------- */
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ApiError> handleNotFound(EntityNotFoundException ex) {
        log.warn("[{}] 404 not_found: {}", cid(), ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new ApiError(cid(), "not_found", ex.getMessage()));
    }

    /* ---------------------------
     *  409 â€“ Conflict / Invalid state
     * --------------------------- */
    @ExceptionHandler(ConflictOperationException.class)
    public ResponseEntity<ApiError> handleConflict(ConflictOperationException ex) {
        log.warn("[{}] 409 conflict: {}", cid(), ex.getMessage());
        return ResponseEntity.status(HttpStatus.CONFLICT)
                .body(new ApiError(cid(), "conflict", ex.getMessage()));
    }

    /* ---------------------------
     *  Pass-through for ResponseStatus* exceptions
     * --------------------------- */
    @ExceptionHandler({ResponseStatusException.class, ErrorResponseException.class})
    public ResponseEntity<ApiError> handleResponseStatus(Exception ex) {
        HttpStatus status;
        String message;

        if (ex instanceof ResponseStatusException rse) {
            status = HttpStatus.valueOf(rse.getStatusCode().value());
            message = (rse.getReason() != null ? rse.getReason() : rse.getMessage());
        } else {
            ErrorResponseException ere = (ErrorResponseException) ex;
            status = HttpStatus.valueOf(ere.getStatusCode().value());
            message = ere.getBody() != null && ere.getBody().getDetail() != null
                    ? ere.getBody().getDetail()
                    : ere.getMessage();
        }

        String errorCode = switch (status) {
            case BAD_REQUEST -> "bad_request";
            case FORBIDDEN -> "forbidden";
            case NOT_FOUND -> "not_found";
            case CONFLICT -> "conflict";
            default -> "error";
        };

        if (status.is4xxClientError()) {
            log.warn("[{}] {} {}: {}", cid(), status.value(), errorCode, message);
        } else {
            log.error("[{}] {} {}: {}", cid(), status.value(), errorCode, message, ex);
        }

        return ResponseEntity.status(status)
                .body(new ApiError(cid(), errorCode, message));
    }

    /* ---------------------------
     *  Fallback â€“ real 500s only
     * --------------------------- */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAny(Exception ex) {
        // Keep stacktrace in logs, short message to client
        log.error("[{}] 500 internal_error", cid(), ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ApiError(cid(), "internal_error", "Unexpected error"));
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/GlobalExceptionHandler.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/AuthController.java =====
package com.oolshik.backend.web;

import com.oolshik.backend.repo.UserRepository;
import com.oolshik.backend.security.JwtService;
import com.oolshik.backend.service.AuthService;
import com.oolshik.backend.service.OtpService;
import com.oolshik.backend.service.UserService;
import com.oolshik.backend.web.dto.AuthDtos.*;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;
import java.util.LinkedHashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final OtpService otp;
    private final UserService userService;
    private final AuthService authService;
    private final UserRepository userRepository;
    private final JwtService jwt;

    public AuthController(OtpService otp, UserService userService, AuthService authService, UserRepository userRepository, JwtService jwt) {
        this.otp = otp;
        this.userService = userService;
        this.authService = authService;
        this.userRepository = userRepository;
        this.jwt = jwt;
    }

    @PostMapping("/otp/request")
    public ResponseEntity<?> otpRequest(@RequestBody @Valid OtpRequest req) {
        var res = otp.requestLoginOtp(req.phone());
        return ResponseEntity.ok(res);
    }

    @PostMapping("/otp/verify")
    public ResponseEntity<?> otpVerify(@RequestBody @Valid OtpVerify req) {
        boolean ok = otp.verifyLoginOtp(req.phone(), req.code());
        if (!ok) return ResponseEntity.badRequest().body(Map.of("error", "Invalid or expired OTP"));
        var user = userService.getOrCreateByPhone(req.phone(), req.displayName(), req.email());
        String access = jwt.generateAccessToken(user.getId(), user.getPhoneNumber());
        String refresh = jwt.generateRefreshToken(user.getId());
        return ResponseEntity.ok(new TokenResponse(access, refresh));
    }

    // Admin password login (ops only)
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody @Valid LoginRequest req) {
        var res = authService.loginWithPassword(req.email(), req.password());
        return ResponseEntity.ok(new TokenResponse((String)res.get("accessToken"), (String)res.get("refreshToken")));
    }

    @PostMapping("/refresh")
    public ResponseEntity<?> refresh(@RequestBody @Valid RefreshRequest req) {
        String access = authService.refreshAccessToken(req.refreshToken());
        return ResponseEntity.ok(Map.of("accessToken", access));
    }

    @GetMapping("/me")
    public ResponseEntity<?> me(@AuthenticationPrincipal User principal) {
        var u = userRepository.findByPhoneNumber(principal.getUsername()).orElseThrow();
        Map<String, Object> out = new LinkedHashMap<>();
        out.put("id", u.getId());
        out.put("phone", u.getPhoneNumber());
        out.put("email", u.getEmail());
        out.put("displayName", u.getDisplayName());
        out.put("roles", u.getRoles());
        out.put("languages", u.getLanguages());
        return ResponseEntity.ok(out);
    }

    @PutMapping("/me")
    public ResponseEntity<?> updateMe(@AuthenticationPrincipal User principal, @RequestBody Map<String, Object> patch) {
        var u = userRepository.findByPhoneNumber(principal.getUsername()).orElseThrow();
        if (patch.containsKey("displayName")) u.setDisplayName(String.valueOf(patch.get("displayName")));
        if (patch.containsKey("languages")) u.setLanguages(String.valueOf(patch.get("languages")));
        if (patch.containsKey("email")) u.setEmail(String.valueOf(patch.get("email")));
        userRepository.save(u);
        return ResponseEntity.ok(Map.of("message", "updated"));
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/AuthController.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/ReportController.java =====
// src/main/java/com/oolshik/backend/web/ReportController.java
package com.oolshik.backend.web;

import com.oolshik.backend.service.ReportService;
import com.oolshik.backend.web.dto.ReportDtos.CreateRequest;
import com.oolshik.backend.web.dto.ReportDtos.CreateResponse;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

import java.security.Principal;

@RestController
@RequestMapping("/api/reports")
public class ReportController {

    private final ReportService reportService;

    public ReportController(ReportService reportService) {
        this.reportService = reportService;
    }

//    @PostMapping
//    public ResponseEntity<CreateResponse> create(User principal, @RequestBody @Valid CreateRequest body) {
//        // principal.getUsername() is the phone number in your app
//        var res = reportService.create(principal.getUsername(), body);
//        return ResponseEntity.ok(res);
//    }

    @PostMapping
    public ResponseEntity<CreateResponse> create(Principal principal, @RequestBody CreateRequest req) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(reportService.create(principal.getName(), req));
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/ReportController.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/HelpRequestController.java =====
package com.oolshik.backend.web;

import com.oolshik.backend.entity.HelpRequestEntity;
import com.oolshik.backend.repo.HelpRequestRow;
import com.oolshik.backend.repo.UserRepository;
import com.oolshik.backend.service.HelpRequestService;
import com.oolshik.backend.web.dto.HelpRequestDtos;
import com.oolshik.backend.web.dto.HelpRequestDtos.CreateRequest;
import com.oolshik.backend.web.dto.HelpRequestDtos.HelpRequestView;
import jakarta.validation.Valid;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/requests")
public class HelpRequestController {

    private final HelpRequestService service;
    private final UserRepository userRepo;

    public HelpRequestController(HelpRequestService service, UserRepository userRepo) {
        this.service = service;
        this.userRepo = userRepo;
    }

    @PostMapping
    public ResponseEntity<?> create(@AuthenticationPrincipal User principal, @RequestBody @Valid CreateRequest req) {
        var requester = userRepo.findByPhoneNumber(principal.getUsername()).orElseThrow();
        HelpRequestEntity created = service.create(
                requester.getId(),
                req.title(), req.description(),
                req.latitude(), req.longitude(),
                req.radiusMeters()
        );
        return ResponseEntity.ok(view(created));
    }

    @GetMapping("/nearby")
    public Page<HelpRequestRow> nearby(
        @RequestParam double lat,
        @RequestParam double lng,
        @RequestParam int radiusMeters,
        @RequestParam(required = false) List<String> statuses,
        @PageableDefault(size = 50) Pageable pageable
    ) {
        return service.nearby(lat, lng, radiusMeters, statuses, pageable);
    }

    @PostMapping("/{id}/accept")
    public ResponseEntity<?> accept(@AuthenticationPrincipal User principal, @PathVariable UUID id) {
        var helper = userRepo.findByPhoneNumber(principal.getUsername()).orElseThrow();
        var updated = service.accept(id, helper.getId());
        return ResponseEntity.ok(view(updated));
    }

    @PostMapping("/{id}/complete")
    public ResponseEntity<?> complete(@AuthenticationPrincipal User principal, @PathVariable UUID id) {
        var requester = userRepo.findByPhoneNumber(principal.getUsername()).orElseThrow();
        var updated = service.complete(id, requester.getId());
        return ResponseEntity.ok(view(updated));
    }

    @PostMapping("/{id}/cancel")
    public ResponseEntity<?> cancel(@AuthenticationPrincipal User principal, @PathVariable UUID id) {
        var requester = userRepo.findByPhoneNumber(principal.getUsername()).orElseThrow();
        var updated = service.cancel(id, requester.getId());
        return ResponseEntity.ok(view(updated));
    }

    private HelpRequestView view(HelpRequestEntity e) {
        return new HelpRequestView(
                e.getId(), e.getTitle(), e.getDescription(),
                e.getLatitude(), e.getLongitude(),
                e.getRadiusMeters(), e.getStatus(),
                e.getRequesterId(), e.getHelperId(),
                e.getCreatedAt()
        );
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/HelpRequestController.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/PhoneRevealController.java =====
package com.oolshik.backend.web;

import com.oolshik.backend.repo.UserRepository;
import com.oolshik.backend.service.PhoneRevealService;
import com.oolshik.backend.web.dto.PhoneRevealDtos.RevealPhoneResponse;
import com.oolshik.backend.web.error.ConflictOperationException;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/requests")
public class PhoneRevealController {

    private final PhoneRevealService phoneRevealService;
    private final UserRepository userRepository;

    public PhoneRevealController(PhoneRevealService phoneRevealService, UserRepository userRepository) {
        this.phoneRevealService = phoneRevealService;
        this.userRepository = userRepository;
    }

    @PostMapping("/{id}/revealPhone")
    public ResponseEntity<RevealPhoneResponse> revealPhone(
            @AuthenticationPrincipal User principal,
            @PathVariable("id") UUID helpRequestId) {

        // principal.getUsername() is the login (your project logs show it is phone)
        var viewer = userRepository.findByPhoneNumber(principal.getUsername())
                .orElseThrow(() -> new ConflictOperationException("Viewer not found"));

        var body = phoneRevealService.revealPhone(helpRequestId, viewer.getId());
        return ResponseEntity.ok(body);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/PhoneRevealController.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/dto/AuthDtos.java =====
package com.oolshik.backend.web.dto;

import jakarta.validation.constraints.*;

public class AuthDtos {

    public record OtpRequest(
            @NotBlank @Pattern(regexp = "^\\+?[0-9]{10,15}$", message = "Invalid phone format") String phone
    ) {}

    public record OtpVerify(
            @NotBlank String phone,
            @NotBlank @Size(min = 4, max = 8) String code,
            String displayName,
            @Email String email
    ) {}

    public record LoginRequest(
            @Email @NotBlank String email,
            @NotBlank String password
    ) {}

    public record TokenResponse(String accessToken, String refreshToken) {}
    public record RefreshRequest(@NotBlank String refreshToken) {}
}
===== END FILE: src/main/java/com/oolshik/backend/web/dto/AuthDtos.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/dto/ReportDtos.java =====
// src/main/java/com/oolshik/backend/web/dto/ReportDtos.java
package com.oolshik.backend.web.dto;

import com.oolshik.backend.domain.ReportReason;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.UUID;

public class ReportDtos {
    public record CreateRequest(
            UUID taskId,
            UUID targetUserId,
            @NotNull ReportReason reason,
            @Size(max = 1000) String text
    ) {}
    public record CreateResponse(UUID id) {}
}
===== END FILE: src/main/java/com/oolshik/backend/web/dto/ReportDtos.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/dto/HelpRequestDtos.java =====
package com.oolshik.backend.web.dto;

import com.oolshik.backend.domain.HelpRequestStatus;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.OffsetDateTime;
import java.util.UUID;

public class HelpRequestDtos {

    public record CreateRequest(
        @NotBlank String title,
        String description,
        @NotNull Double latitude,
        @NotNull Double longitude,
        @Min(50) @Max(10000) Integer radiusMeters
    ) {}

    public record HelpRequestView(
        UUID id,
        String title,
        String description,
        double latitude,
        double longitude,
        int radiusMeters,
        HelpRequestStatus status,
        UUID requesterId,
        UUID helperId,
        OffsetDateTime createdAt
    ) {}
}
===== END FILE: src/main/java/com/oolshik/backend/web/dto/HelpRequestDtos.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/dto/PhoneRevealDtos.java =====
package com.oolshik.backend.web.dto;

public class PhoneRevealDtos {
    public record RevealPhoneResponse(String phoneNumber, long revealCount) {}
}
===== END FILE: src/main/java/com/oolshik/backend/web/dto/PhoneRevealDtos.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/filter/CorrelationIdFilter.java =====
package com.oolshik.backend.web.filter;

import org.slf4j.MDC;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.UUID;

/**
 * Ensures each request has a correlation id (cid) that propagates to logs.
 */
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class CorrelationIdFilter extends OncePerRequestFilter {

    public static final String CID = "cid";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String incoming = request.getHeader("X-Correlation-Id");
        String cid = (incoming == null || incoming.isBlank()) ? UUID.randomUUID().toString() : incoming;
        MDC.put(CID, cid);
        response.setHeader("X-Correlation-Id", cid);
        try {
            filterChain.doFilter(request, response);
        } finally {
            MDC.remove(CID);
        }
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/filter/CorrelationIdFilter.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/filter/RequestResponseLoggingFilter.java =====
package com.oolshik.backend.web.filter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 10)
public class RequestResponseLoggingFilter extends OncePerRequestFilter {

    private static final Logger log = LoggerFactory.getLogger(RequestResponseLoggingFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        long start = System.currentTimeMillis();
        String cid = MDC.get("cid"); // set by CorrelationIdFilter
        String method = request.getMethod();
        String uri = request.getRequestURI();
        String qs = request.getQueryString();
        String full = (qs == null) ? uri : (uri + "?" + qs);
        String auth = request.getHeader("Authorization");
        String authShort = (auth == null) ? "none" : (auth.startsWith("Bearer ") ? "bearer" : "other");

        log.info("[{}] â‡¢ {} {} auth={}", cid, method, full, authShort);
        try {
            filterChain.doFilter(request, response);
        } finally {
            long dur = System.currentTimeMillis() - start;
            log.info("[{}] â‡  {} {} -> {} {}ms", cid, method, full, response.getStatus(), dur);
        }
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/filter/RequestResponseLoggingFilter.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/error/ForbiddenOperationException.java =====
package com.oolshik.backend.web.error;

public class ForbiddenOperationException extends RuntimeException {
    public ForbiddenOperationException(String message) {
        super(message);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/error/ForbiddenOperationException.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/web/error/ConflictOperationException.java =====
package com.oolshik.backend.web.error;

public class ConflictOperationException extends RuntimeException {
    public ConflictOperationException(String message) {
        super(message);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/web/error/ConflictOperationException.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/aop/LoggingAspect.java =====
package com.oolshik.backend.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.stereotype.Component;

import java.util.Arrays;

@Aspect
@Component
public class LoggingAspect {

    private static final Logger log = LoggerFactory.getLogger(LoggingAspect.class);

    // Controllers, Services, Repositories under our base package
    @Pointcut("within(com.oolshik.backend..*)")
    public void applicationPackagePointcut() {}

    // Only public methods
    @Pointcut("execution(public * *(..))")
    public void publicMethodPointcut() {}

    @Around("applicationPackagePointcut() && publicMethodPointcut()")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        String sig = joinPoint.getSignature().toShortString();
        String args = Arrays.toString(joinPoint.getArgs());
        String cid = MDC.get("cid");
        long startNanos = System.nanoTime();
        log.info("[{}] â–¶ {} args={}", cid, sig, args);
        try {
            Object result = joinPoint.proceed();
            long durMs = (System.nanoTime() - startNanos) / 1_000_000;
            String resStr = (result == null) ? "null" : result.getClass().getSimpleName();
            log.info("[{}] â—€ {} ok in {}ms -> {}", cid, sig, durMs, resStr);
            return result;
        } catch (Throwable ex) {
            long durMs = (System.nanoTime() - startNanos) / 1_000_000;
            log.error("[{}] âœ– {} failed in {}ms: {}", cid, sig, durMs, ex.toString(), ex);
            throw ex;
        }
    }
}
===== END FILE: src/main/java/com/oolshik/backend/aop/LoggingAspect.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/common/ApiError.java =====
package com.oolshik.backend.common;

public record ApiError(String code, String message) {
    public static ApiError of(String code, String message) { return new ApiError(code, message); }
}
===== END FILE: src/main/java/com/oolshik/backend/common/ApiError.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/service/PhoneRevealService.java =====
package com.oolshik.backend.service;

import com.oolshik.backend.entity.HelpRequestEntity;
import com.oolshik.backend.entity.PhoneRevealEventEntity;
import com.oolshik.backend.entity.UserEntity;
import com.oolshik.backend.repo.HelpRequestRepository;
import com.oolshik.backend.repo.PhoneRevealEventRepository;
import com.oolshik.backend.repo.UserRepository;
import com.oolshik.backend.web.dto.PhoneRevealDtos.RevealPhoneResponse;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
public class PhoneRevealService {

    private final HelpRequestRepository helpRequestRepository;
    private final UserRepository userRepository;
    private final PhoneRevealEventRepository phoneRevealRepo;

    public PhoneRevealService(
            HelpRequestRepository helpRequestRepository,
            UserRepository userRepository,
            PhoneRevealEventRepository phoneRevealRepo) {
        this.helpRequestRepository = helpRequestRepository;
        this.userRepository = userRepository;
        this.phoneRevealRepo = phoneRevealRepo;
    }

    @Transactional
    public RevealPhoneResponse revealPhone(UUID helpRequestId, UUID viewerUserId) {
        HelpRequestEntity hr = helpRequestRepository.findById(helpRequestId)
                .orElseThrow(() -> new EntityNotFoundException("Request not found"));

        UserEntity requester = userRepository.findById(hr.getRequesterId())
                .orElseThrow(() -> new EntityNotFoundException("Requester not found"));

        UserEntity viewer = userRepository.findById(viewerUserId)
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        String fullNumber = requester.getPhoneNumber();


        PhoneRevealEventEntity ev = new PhoneRevealEventEntity();
        ev.setPhoneNumber(fullNumber);
        ev.setRequesterUserId(helpRequestId);
        ev.setTargetUserId(viewerUserId);
        phoneRevealRepo.save(ev);

        long count = phoneRevealRepo.countByRequesterUserId(helpRequestId);
        return new RevealPhoneResponse(fullNumber, count);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/service/PhoneRevealService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/service/ReportService.java =====
// src/main/java/com/oolshik/backend/service/ReportService.java
package com.oolshik.backend.service;

import com.oolshik.backend.domain.ReportReason;
import com.oolshik.backend.entity.HelpRequestEntity;
import com.oolshik.backend.entity.ReportEventEntity;
import com.oolshik.backend.entity.UserEntity;
import com.oolshik.backend.repo.HelpRequestRepository;
import com.oolshik.backend.repo.ReportEventRepository;
import com.oolshik.backend.repo.UserRepository;
import com.oolshik.backend.web.dto.ReportDtos.CreateRequest;
import com.oolshik.backend.web.dto.ReportDtos.CreateResponse;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.http.HttpStatus;

import java.util.UUID;

@Service
public class ReportService {

    private final UserRepository userRepo;
    private final HelpRequestRepository helpRepo;
    private final ReportEventRepository reportRepo;

    public ReportService(UserRepository userRepo,
                         HelpRequestRepository helpRepo,
                         ReportEventRepository reportRepo) {
        this.userRepo = userRepo;
        this.helpRepo = helpRepo;
        this.reportRepo = reportRepo;
    }

    @Transactional
    public CreateResponse create(String principalPhone, CreateRequest req) {
        // Who is reporting?
        UserEntity reporter = userRepo.findByPhoneNumber(principalPhone)
                .orElseThrow(() -> new EntityNotFoundException("Reporter not found"));

        // Validate context: **exactly one** of taskId or targetUserId
        final UUID helpRequestId   = req.taskId();
        final UUID explicitTarget  = req.targetUserId();

        if (helpRequestId == null && explicitTarget == null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "Either taskId or targetUserId is required");
        }
        if (helpRequestId != null && explicitTarget != null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "Provide only one of taskId or targetUserId");
        }

        // If OTHER, details are required
        if (req.reason() == ReportReason.OTHER && (req.text() == null || req.text().isBlank())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "Details are required when reason is OTHER");
        }

        // Resolve target user
        UUID targetUserId;
        if (helpRequestId != null) {
            HelpRequestEntity hr = helpRepo.findById(helpRequestId)
                    .orElseThrow(() -> new EntityNotFoundException("Task not found"));
            targetUserId = hr.getRequesterId(); // inferred from the task
            if (targetUserId == null) {
                throw new ResponseStatusException(HttpStatus.CONFLICT,
                        "Task has no requester to report");
            }
            // If you *want* to allow reporting the helper instead, add a switch here.
        } else {
            // targetUserId flow
            userRepo.findById(explicitTarget)
                    .orElseThrow(() -> new EntityNotFoundException("Target user not found"));
            targetUserId = explicitTarget;
        }

        // Prevent self-reporting (optional but sensible)
        if (reporter.getId().equals(targetUserId)) {
            throw new ResponseStatusException(HttpStatus.FORBIDDEN,
                    "You cannot report yourself");
        }

        // Optional: dedupe to avoid spam (uncomment if you add this repo method)
        // boolean exists = reportRepo.existsByReporterUserIdAndTargetUserIdAndHelpRequestIdAndReason(
        //         reporter.getId(), targetUserId, helpRequestId, req.reason());
        // if (exists) {
        //     throw new ResponseStatusException(HttpStatus.CONFLICT, "You already reported this");
        // }

        // Persist
        ReportEventEntity ev = new ReportEventEntity();
        ev.setReporterUserId(reporter.getId());
        ev.setTargetUserId(targetUserId);
        ev.setHelpRequestId(helpRequestId); // may be null in user-report flow
        ev.setReason(req.reason());
        ev.setDetails((req.text() != null && !req.text().isBlank()) ? req.text().trim() : null);

        reportRepo.save(ev);
        return new CreateResponse(ev.getId());
    }
}
===== END FILE: src/main/java/com/oolshik/backend/service/ReportService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/service/HelpRequestService.java =====
package com.oolshik.backend.service;

import com.oolshik.backend.domain.HelpRequestStatus;
import com.oolshik.backend.entity.HelpRequestEntity;
import com.oolshik.backend.entity.UserEntity;
import com.oolshik.backend.repo.HelpRequestRepository;
import com.oolshik.backend.repo.HelpRequestRow;
import com.oolshik.backend.repo.UserRepository;
import com.oolshik.backend.web.error.ForbiddenOperationException;
import com.oolshik.backend.web.error.ConflictOperationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;

@Service
public class HelpRequestService {

    private final HelpRequestRepository repo;
    private final UserRepository userRepo;

    public HelpRequestService(HelpRequestRepository repo, UserRepository userRepo) {
        this.repo = repo;
        this.userRepo = userRepo;
    }

    @Transactional
    public HelpRequestEntity create(UUID requesterId, String title, String description, double lat, double lon, int radiusMeters) {
        UserEntity requester = userRepo.findById(requesterId).orElseThrow(() -> new IllegalArgumentException("Requester not found"));
        HelpRequestEntity e = new HelpRequestEntity();
        e.setRequesterId(requester.getId());
        e.setTitle(title);
        e.setDescription(description);
        e.setLatitude(lat);
        e.setLongitude(lon);
        e.setRadiusMeters(radiusMeters);
        e.setStatus(HelpRequestStatus.OPEN);
        return repo.save(e);
    }

    public Page<HelpRequestRow> nearby(
        double lat, double lng, int radiusMeters,
        List<String> statuses, Pageable pageable
    ) {

        String statusesCsv = (statuses == null || statuses.isEmpty())
            ? ""  // value ignored when statusesEmpty = true
            : String.join(",", statuses);
        // call repo:
        return repo.findNearbyPaged(lat, lng, radiusMeters, statusesCsv, pageable);
    }
    

    @Transactional
    public HelpRequestEntity accept(UUID requestId, UUID helperId) {
        HelpRequestEntity e = repo.findById(requestId).orElseThrow(() -> new IllegalArgumentException("Request not found"));
        if (e.getStatus() != HelpRequestStatus.OPEN) {
            throw new ConflictOperationException("Request not open"); // 409
        }
        e.setStatus(HelpRequestStatus.ASSIGNED);
        e.setHelperId(helperId);
        return repo.save(e);
    }

    @Transactional
    public HelpRequestEntity complete(UUID requestId, UUID requesterId) {
        HelpRequestEntity e = repo.findById(requestId).orElseThrow(() -> new IllegalArgumentException("Request not found"));
        if (!requesterId.equals(e.getRequesterId())) {
            throw new ForbiddenOperationException("Only requester can complete"); // -> 403
        }
        e.setStatus(HelpRequestStatus.COMPLETED);
        return repo.save(e);
    }

    @Transactional
    public HelpRequestEntity cancel(UUID requestId, UUID requesterId) {
        HelpRequestEntity e = repo.findById(requestId).orElseThrow(() -> new IllegalArgumentException("Request not found"));
        if (!requesterId.equals(e.getRequesterId())) {
            throw new ForbiddenOperationException("Only requester can cancel"); // -> 403
        }
        e.setStatus(HelpRequestStatus.CANCELLED);
        return repo.save(e);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/service/HelpRequestService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/service/UserService.java =====
package com.oolshik.backend.service;

import com.oolshik.backend.domain.Role;
import com.oolshik.backend.entity.UserEntity;
import com.oolshik.backend.repo.UserRepository;
import com.oolshik.backend.util.PhoneUtil;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.*;

@Service
public class UserService {

    private final UserRepository repo;
    public UserService(UserRepository repo) { this.repo = repo; }

    @Transactional
    public UserEntity getOrCreateByPhone(String rawPhone, String displayName, String email) {
        String phone = PhoneUtil.normalize(rawPhone);
        return repo.findByPhoneNumber(phone).orElseGet(() -> {
            UserEntity ue = new UserEntity();
            ue.setPhoneNumber(phone);
            ue.setDisplayName(displayName);
            ue.setEmail(email);
            ue.setRoleSet(new HashSet<>(Collections.singletonList(Role.NETA)));
            return repo.save(ue);
        });
    }
}
===== END FILE: src/main/java/com/oolshik/backend/service/UserService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/service/OtpService.java =====
package com.oolshik.backend.service;

import com.oolshik.backend.domain.OtpPurpose;
import com.oolshik.backend.entity.OtpCodeEntity;
import com.oolshik.backend.repo.OtpCodeRepository;
import com.oolshik.backend.util.PhoneUtil;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Random;

@Service
public class OtpService {

    private final OtpCodeRepository repo;
    private final PasswordEncoder encoder;
    private final SmsSender smsSender;

    private final int ttlSeconds;
    private final int cooldownSeconds;
    private final int maxAttempts;
    private final boolean dev;

    public OtpService(
            OtpCodeRepository repo,
            PasswordEncoder encoder,
            SmsSender smsSender,
            @Value("${app.otp.ttlSeconds:300}") int ttlSeconds,
            @Value("${app.otp.cooldownSeconds:30}") int cooldownSeconds,
            @Value("${app.otp.maxAttempts:5}") int maxAttempts,
            @Value("${spring.profiles.active:}") String activeProfile
    ) {
        this.repo = repo;
        this.encoder = encoder;
        this.smsSender = smsSender;
        this.ttlSeconds = ttlSeconds;
        this.cooldownSeconds = cooldownSeconds;
        this.maxAttempts = maxAttempts;
        this.dev = activeProfile != null && activeProfile.contains("dev");
    }

    private String genCode() {
        int n = new Random().nextInt(900000) + 100000;
        return String.valueOf(n);
    }

    @Transactional
    public Map<String, Object> requestLoginOtp(String rawPhone) {
        String phone = PhoneUtil.normalize(rawPhone);
        OffsetDateTime now = OffsetDateTime.now();
        var last = repo.findFirstByPhoneNumberOrderByCreatedAtDesc(phone).orElse(null);
        if (last != null && last.getLastSentAt() != null &&
            last.getLastSentAt().plusSeconds(cooldownSeconds).isAfter(now)) {
            long wait = last.getLastSentAt().plusSeconds(cooldownSeconds).toEpochSecond() - now.toEpochSecond();
            throw new IllegalStateException("Please wait " + Math.max(wait, 1) + "s before requesting another OTP");
        }

        String code = genCode();
        String hash = encoder.encode(code);

        OtpCodeEntity e = new OtpCodeEntity();
        e.setPhoneNumber(phone);
        e.setCodeHash(hash);
        e.setPurpose(OtpPurpose.LOGIN.name());
        e.setExpiresAt(now.plusSeconds(ttlSeconds));
        e.setAttemptCount(0);
        e.setResendCount(last == null ? 0 : last.getResendCount() + 1);
        e.setLastSentAt(now);
        repo.save(e);

        smsSender.send(phone, "Your Oolshik login code: " + code + " (valid " + (ttlSeconds/60) + " min)");

        if (dev) return Map.of("sent", true, "phone", phone, "devCode", code, "ttlSeconds", ttlSeconds);
        return Map.of("sent", true, "phone", phone, "ttlSeconds", ttlSeconds);
    }

    @Transactional
    public boolean verifyLoginOtp(String rawPhone, String code) {
        String phone = PhoneUtil.normalize(rawPhone);
        OffsetDateTime now = OffsetDateTime.now();
        List<OtpCodeEntity> list = repo.findActive(phone, OtpPurpose.LOGIN.name(), now);
        if (list.isEmpty()) return false;
        OtpCodeEntity e = list.get(0);
        if (e.getAttemptCount() >= maxAttempts) return false;
        e.setAttemptCount(e.getAttemptCount() + 1);
        boolean ok = encoder.matches(code, e.getCodeHash());
        if (ok) e.setConsumedAt(now);
        repo.save(e);
        return ok;
    }
}
===== END FILE: src/main/java/com/oolshik/backend/service/OtpService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/service/AuthService.java =====
package com.oolshik.backend.service;

import com.oolshik.backend.domain.Role;
import com.oolshik.backend.entity.UserEntity;
import com.oolshik.backend.repo.UserRepository;
import com.oolshik.backend.security.JwtService;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.DependsOn;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.*;

@Service
@DependsOn("entityManagerFactory")
public class AuthService implements UserDetailsService {

    private final UserRepository userRepository;
    private final PasswordEncoder encoder;
    private final JwtService jwtService;

    public AuthService(UserRepository userRepository, PasswordEncoder encoder, JwtService jwtService) {
        this.userRepository = userRepository;
        this.encoder = encoder;
        this.jwtService = jwtService;
    }

    @Value("${ADMIN_EMAIL:}")
    private String adminEmail;
    @Value("${ADMIN_PASSWORD:}")
    private String adminPassword;

    @PostConstruct
    public void seedAdmin() {
        if (adminEmail != null && !adminEmail.isBlank() && adminPassword != null && !adminPassword.isBlank()) {
            userRepository.findByEmail(adminEmail).orElseGet(() -> {
                UserEntity e = new UserEntity();
                e.setEmail(adminEmail);
                e.setPhoneNumber("+910000000000");
                e.setPasswordHash(encoder.encode(adminPassword));
                e.setDisplayName("Admin");
                e.setRoleSet(new HashSet<>(Arrays.asList(Role.ADMIN, Role.NETA, Role.KARYAKARTA)));
                return userRepository.save(e);
            });
        }
    }

    @Override
    public UserDetails loadUserByUsername(String phone) throws UsernameNotFoundException {
        UserEntity ue = userRepository.findByPhoneNumber(phone)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Use the concrete list type SimpleGrantedAuthority to avoid generics mismatch
        java.util.List<org.springframework.security.core.authority.SimpleGrantedAuthority> auths =
            ue.getRoleSet().stream()
            .map(r -> new org.springframework.security.core.authority.SimpleGrantedAuthority("ROLE_" + r.name()))
            .toList();

        return new org.springframework.security.core.userdetails.User(
            ue.getPhoneNumber(),
            ue.getPasswordHash() == null ? "" : ue.getPasswordHash(),
            auths  // OK: constructor accepts Collection<? extends GrantedAuthority>
        );
    }

    @Transactional(readOnly = true)
    public Map<String, Object> loginWithPassword(String email, String password) {
        UserEntity ue = userRepository.findByEmail(email).orElseThrow(() -> new IllegalArgumentException("Invalid credentials"));
        if (ue.getPasswordHash() == null || !encoder.matches(password, ue.getPasswordHash())) {
            throw new IllegalArgumentException("Invalid credentials");
        }
        String access = jwtService.generateAccessToken(ue.getId(), ue.getPhoneNumber());
        String refresh = jwtService.generateRefreshToken(ue.getId());
        return Map.of("userId", ue.getId(), "accessToken", access, "refreshToken", refresh);
    }

    public String refreshAccessToken(String refreshToken) {
        var jws = jwtService.parse(refreshToken);
        String typ = jws.getBody().get("typ", String.class);
        if (!"refresh".equals(typ)) throw new IllegalArgumentException("Not a refresh token");
        UUID userId = UUID.fromString(jws.getBody().getSubject());
        UserEntity ue = userRepository.findById(userId).orElseThrow(() -> new IllegalArgumentException("User missing"));
        return jwtService.generateAccessToken(ue.getId(), ue.getPhoneNumber());
    }
}
===== END FILE: src/main/java/com/oolshik/backend/service/AuthService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/service/SmsSender.java =====
package com.oolshik.backend.service; public interface SmsSender { void send(String phone, String message); }
===== END FILE: src/main/java/com/oolshik/backend/service/SmsSender.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/service/DevSmsSender.java =====
package com.oolshik.backend.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@Profile("dev")
public class DevSmsSender implements SmsSender {
    private static final Logger log = LoggerFactory.getLogger(DevSmsSender.class);
    @Override
    public void send(String phone, String message) { log.info("[DEV SMS] to {}: {}", phone, message); }
}
===== END FILE: src/main/java/com/oolshik/backend/service/DevSmsSender.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/domain/ReportReason.java =====
package com.oolshik.backend.domain;

public enum ReportReason {
    SPAM, INAPPROPRIATE, UNSAFE, OTHER
}
===== END FILE: src/main/java/com/oolshik/backend/domain/ReportReason.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/domain/Role.java =====
package com.oolshik.backend.domain; public enum Role { NETA, KARYAKARTA, ADMIN }
===== END FILE: src/main/java/com/oolshik/backend/domain/Role.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/domain/HelpRequestStatus.java =====
package com.oolshik.backend.domain; public enum HelpRequestStatus { OPEN, ASSIGNED, COMPLETED, CANCELLED }
===== END FILE: src/main/java/com/oolshik/backend/domain/HelpRequestStatus.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/domain/OtpPurpose.java =====
package com.oolshik.backend.domain; public enum OtpPurpose { LOGIN }
===== END FILE: src/main/java/com/oolshik/backend/domain/OtpPurpose.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/repo/HelpRequestRow.java =====
package com.oolshik.backend.repo;

import java.time.Instant;
import java.util.UUID;

public interface HelpRequestRow {
    UUID getId();
    String getTitle();
    String getDescription();
    Double getLatitude();
    Double getLongitude();
    Integer getRadiusMeters();
    String getStatus();
    UUID getRequesterId();
    String getCreatedByName();
    String getCreatedByPhoneNumber();
    UUID getHelperId();
    Instant getCreatedAt();
    Instant getUpdatedAt();
}
===== END FILE: src/main/java/com/oolshik/backend/repo/HelpRequestRow.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/repo/PhoneRevealEventRepository.java =====
package com.oolshik.backend.repo;

import com.oolshik.backend.entity.PhoneRevealEventEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.UUID;

public interface PhoneRevealEventRepository extends JpaRepository<PhoneRevealEventEntity, UUID> {
    long countByRequesterUserId(UUID requesterUserId);
}
===== END FILE: src/main/java/com/oolshik/backend/repo/PhoneRevealEventRepository.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/repo/OtpCodeRepository.java =====
package com.oolshik.backend.repo;

import com.oolshik.backend.entity.OtpCodeEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface OtpCodeRepository extends JpaRepository<OtpCodeEntity, UUID> {

    @Query("SELECT o FROM OtpCodeEntity o WHERE o.phoneNumber = ?1 AND o.purpose = ?2 AND o.expiresAt > ?3 AND o.consumedAt IS NULL ORDER BY o.createdAt DESC")
    List<OtpCodeEntity> findActive(String phone, String purpose, OffsetDateTime now);

    Optional<OtpCodeEntity> findFirstByPhoneNumberOrderByCreatedAtDesc(String phone);
}
===== END FILE: src/main/java/com/oolshik/backend/repo/OtpCodeRepository.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/repo/UserRepository.java =====
package com.oolshik.backend.repo;

import com.oolshik.backend.entity.UserEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;
import java.util.UUID;

public interface UserRepository extends JpaRepository<UserEntity, UUID> {
    Optional<UserEntity> findByPhoneNumber(String phoneNumber);
    Optional<UserEntity> findByEmail(String email);
    boolean existsByPhoneNumber(String phoneNumber);
    boolean existsByEmail(String email);
}
===== END FILE: src/main/java/com/oolshik/backend/repo/UserRepository.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/repo/HelpRequestRepository.java =====
package com.oolshik.backend.repo;

import com.oolshik.backend.entity.HelpRequestEntity;
import com.oolshik.backend.web.dto.HelpRequestDtos;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.UUID;

public interface HelpRequestRepository extends JpaRepository<HelpRequestEntity, UUID> {

  @Query(
          value = """
    SELECT
      h.id,
      h.title,
      h.description,
      h.latitude,
      h.longitude,
      h.radius_meters  AS radiusMeters,
      h.status,
      h.requester_id   AS requesterId,
      u.display_name   AS createdByName,
      u.phone_number   AS createdByPhoneNumber,
      h.helper_id      AS helperId,
      h.created_at     AS createdAt,
      h.updated_at     AS updatedAt
    FROM help_request h
    JOIN app_user u ON u.id = h.requester_id
    WHERE
      (COALESCE(:statusesCsv, '') = '' OR h.status::text = ANY(string_to_array(:statusesCsv, ',')))
      AND (
        6371.0 * acos(
          LEAST(GREATEST(
            cos(radians(:lat)) * cos(radians(h.latitude)) *
            cos(radians(h.longitude) - radians(:lng)) +
            sin(radians(:lat)) * sin(radians(h.latitude))
          , -1), 1)
        )
      ) <= (:radiusMeters / 1000.0)
    ORDER BY
      ( 6371.0 * acos(
        LEAST(GREATEST(
          cos(radians(:lat)) * cos(radians(h.latitude)) *
          cos(radians(h.longitude) - radians(:lng)) +
          sin(radians(:lat)) * sin(radians(h.latitude))
        , -1), 1)
      ) ) ASC,
      h.created_at DESC
  """,
          countQuery = """
    SELECT COUNT(*)
    FROM help_request h
    JOIN app_user u ON u.id = h.requester_id
    WHERE
      (COALESCE(:statusesCsv, '') = '' OR h.status::text = ANY(string_to_array(:statusesCsv, ',')))
      AND (
        6371.0 * acos(
          LEAST(GREATEST(
            cos(radians(:lat)) * cos(radians(h.latitude)) *
            cos(radians(h.longitude) - radians(:lng)) +
            sin(radians(:lat)) * sin(radians(h.latitude))
          , -1), 1)
        )
      ) <= (:radiusMeters / 1000.0)
  """,
          nativeQuery = true
  )
  Page<HelpRequestRow> findNearbyPaged(
          @Param("lat") double lat,
          @Param("lng") double lng,
          @Param("radiusMeters") int radiusMeters,
          @Param("statusesCsv") String statusesCsv,
          Pageable pageable
  );
}
===== END FILE: src/main/java/com/oolshik/backend/repo/HelpRequestRepository.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/repo/ReportEventRepository.java =====
// src/main/java/com/oolshik/backend/repo/ReportEventRepository.java
package com.oolshik.backend.repo;

import com.oolshik.backend.entity.ReportEventEntity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.UUID;

public interface ReportEventRepository extends JpaRepository<ReportEventEntity, UUID> {
}
===== END FILE: src/main/java/com/oolshik/backend/repo/ReportEventRepository.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/S3StorageService.java =====
package com.oolshik.backend.media;

import org.springframework.util.StringUtils;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.core.ResponseInputStream;
import software.amazon.awssdk.core.sync.RequestBody;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.*;
import software.amazon.awssdk.services.s3.presigner.S3Presigner;
import software.amazon.awssdk.services.s3.presigner.model.*;

import java.io.*;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;

public class S3StorageService implements StorageService {

    private final S3Client s3;
    private final S3Presigner presigner;
    private final String bucket;
    private final String prefix;
    private final Path tmpRoot;

    public S3StorageService(String bucket, String region, String prefix, String endpoint, boolean pathStyle) throws IOException {
        this.bucket = bucket;
        this.prefix = prefix != null ? prefix : "audio/";
        var base = S3Client.builder()
                .region(Region.of(region))
                .credentialsProvider(DefaultCredentialsProvider.create());
        var pre = S3Presigner.builder().region(Region.of(region)).credentialsProvider(DefaultCredentialsProvider.create());
        if (StringUtils.hasText(endpoint)) {
            var uri = URI.create(endpoint);
            base = base.endpointOverride(uri);
            pre = pre.endpointOverride(uri);
        }
        if (pathStyle) {
            base = base.serviceConfiguration(cfg -> cfg.pathStyleAccessEnabled(true));
        }
        this.s3 = base.build();
        this.presigner = pre.build();
        this.tmpRoot = Paths.get("./data/audio/tmp-s3").toAbsolutePath();
        Files.createDirectories(tmpRoot);
    }

    private String key(String finalKey) {
        String k = (prefix.endsWith("/") ? prefix : prefix + "/") + finalKey;
        return k.replace("//", "/");
    }

    @Override
    public String writeTemp(String uploadId) throws IOException {
        Path p = tmpRoot.resolve(uploadId + ".part");
        Files.deleteIfExists(p);
        Files.createFile(p);
        return p.toString();
    }

    @Override
    public void append(String tempKey, byte[] bytes) throws IOException {
        try (OutputStream out = new BufferedOutputStream(new FileOutputStream(tempKey, true))) {
            out.write(bytes);
        }
    }

    @Override
    public String finalizeUpload(String tempKey, String finalKey) throws IOException {
        Path src = Paths.get(tempKey);
        String s3key = key(finalKey);
        try (InputStream in = new BufferedInputStream(new FileInputStream(src.toFile()))) {
            PutObjectRequest req = PutObjectRequest.builder()
                    .bucket(bucket)
                    .key(s3key)
                    .contentType("audio/m4a")
                    .build();
            s3.putObject(req, RequestBody.fromInputStream(in, Files.size(src)));
        } catch (S3Exception e) {
            throw new IOException("S3 putObject failed: " + e.awsErrorDetails().errorMessage(), e);
        } finally {
            Files.deleteIfExists(src);
        }
        return s3key;
    }

    @Override
    public InputStream readRange(String key, long start, long end) throws IOException {
        String range = "bytes=" + start + "-" + end;
        GetObjectRequest req = GetObjectRequest.builder()
                .bucket(bucket)
                .key(key)
                .range(range)
                .build();
        try {
            ResponseInputStream<GetObjectResponse> in = s3.getObject(req);
            return in;
        } catch (S3Exception e) {
            throw new IOException("S3 getObject failed: " + e.awsErrorDetails().errorMessage(), e);
        }
    }

    @Override
    public long size(String key) throws IOException {
        HeadObjectRequest req = HeadObjectRequest.builder().bucket(bucket).key(key).build();
        try {
            HeadObjectResponse head = s3.headObject(req);
            return head.contentLength();
        } catch (S3Exception e) {
            throw new IOException("S3 headObject failed: " + e.awsErrorDetails().errorMessage(), e);
        }
    }

    @Override
    public void delete(String key) throws IOException {
        try {
            s3.deleteObject(DeleteObjectRequest.builder().bucket(bucket).key(key).build());
        } catch (S3Exception e) {
            throw new IOException("S3 deleteObject failed: " + e.awsErrorDetails().errorMessage(), e);
        }
    }

    // ---- Presigned MPU helpers (Phase 2) ----
    public CreateMultipartUploadResponse mpuCreate(String objectKey, String mimeType) {
        CreateMultipartUploadRequest req = CreateMultipartUploadRequest.builder()
                .bucket(bucket).key(objectKey).contentType(mimeType).build();
        return s3.createMultipartUpload(req);
    }

    public String presignPartUrl(String uploadId, String objectKey, int partNumber, Duration ttl) {
        UploadPartRequest upr = UploadPartRequest.builder()
                .bucket(bucket).key(objectKey).uploadId(uploadId).partNumber(partNumber).build();
        PresignedUploadPartRequest p = presigner.presignUploadPart(b -> b
                .signatureDuration(ttl).uploadPartRequest(upr));
        return p.url().toString();
    }

    public void mpuComplete(String uploadId, String objectKey, java.util.List<Dtos.PartETag> parts) {
        CompletedMultipartUpload cmp = CompletedMultipartUpload.builder().parts(
                parts.stream()
                        .map(p -> CompletedPart.builder().partNumber(p.partNumber()).eTag(p.eTag()).build())
                        .toList()
        ).build();
        CompleteMultipartUploadRequest req = CompleteMultipartUploadRequest.builder()
                .bucket(bucket).key(objectKey).uploadId(uploadId).multipartUpload(cmp).build();
        s3.completeMultipartUpload(req);
    }

    public void mpuAbort(String uploadId, String objectKey) {
        AbortMultipartUploadRequest req = AbortMultipartUploadRequest.builder()
                .bucket(bucket).key(objectKey).uploadId(uploadId).build();
        s3.abortMultipartUpload(req);
    }

    public String presignPutUrl(String key, String contentType, Duration ttl) {
        PutObjectRequest put = PutObjectRequest.builder()
                .bucket(bucket)
                .key(key)
                .contentType(contentType)
                .build();
        PresignedPutObjectRequest pre = presigner.presignPutObject(b -> b
                .signatureDuration(ttl)
                .putObjectRequest(put));
        return pre.url().toString();
    }

    public String toPublicUrl(String key) {
        // naive S3 URL; if you use CloudFront, return that instead.
        // Note: for private buckets this wonâ€™t be directly playable; you would need signed GETs.
        String regionHost = "s3." + s3.serviceClientConfiguration().region().toString().toLowerCase() + ".amazonaws.com";
        return "https://" + bucket + "." + regionHost + "/" + key;
    }
}
===== END FILE: src/main/java/com/oolshik/backend/media/S3StorageService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/MultipartUploadService.java =====
package com.oolshik.backend.media;

import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class MultipartUploadService {

    private final StorageService storage;
    private final Map<String, String> tempKeyByUploadId = new ConcurrentHashMap<>();

    public MultipartUploadService(StorageService storage) {
        this.storage = storage;
    }

    public String initUpload() throws IOException {
        String uploadId = UUID.randomUUID().toString();
        String tempKey = storage.writeTemp(uploadId);
        tempKeyByUploadId.put(uploadId, tempKey);
        return uploadId;
    }

    public void appendChunk(String uploadId, byte[] bytes) throws IOException {
        String tempKey = tempKeyByUploadId.get(uploadId);
        if (tempKey == null) throw new IllegalStateException("Unknown uploadId");
        synchronized (tempKey.intern()) {
            storage.append(tempKey, bytes);
        }
    }

    public String finalizeUpload(String uploadId, String finalKey) throws IOException {
        String tempKey = tempKeyByUploadId.remove(uploadId);
        if (tempKey == null) throw new IllegalStateException("Unknown uploadId");
        return storage.finalizeUpload(tempKey, finalKey);
    }
}
===== END FILE: src/main/java/com/oolshik/backend/media/MultipartUploadService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/AudioController.java =====
package com.oolshik.backend.media;

import com.oolshik.backend.media.Dtos.*;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.util.List;
import java.util.UUID;


//# Oolshik Audio Backend (Aligned & Phase-ready)
//
//- **Phase 1**: Server-buffered chunk upload -> finalize to Local or S3 (same API)
//- **Phase 2**: Optional client direct-to-S3 (presigned multipart) endpoints under `/mpu/*`
//- **Phase 3+**: Add transcription, retention, sharing without changing upload APIs
//
//## Endpoints
//- POST `/api/media/audio/init`, PUT `/api/media/audio/{uploadId}/chunk?index=N`, POST `/complete`
//- GET `/api/media/audio/my`, GET `/api/media/audio/{id}/stream` (Range), DELETE `/{id}`
//- POST `/api/media/audio/mpu/create|sign-part|complete|abort` (S3 only)

//## Security
//Protect `/api/media/**` for authenticated users (JWT). `auth.getName()` is used as `ownerUserId`.

@RestController
@RequestMapping("/api/media/audio")
public class AudioController {

    private final MultipartUploadService multipart;
    private final StorageService storage;
    private final AudioFileRepository repo;

    public AudioController(MultipartUploadService multipart,
                           StorageService storage,
                           AudioFileRepository repo) {
        this.multipart = multipart;
        this.storage = storage; // single bean named 'storageService'
        this.repo = repo;
    }

    // -------- Phase 1: Server-buffered chunk upload --------
    @PostMapping("/init")
    public InitUploadResp init(@RequestBody InitUploadReq req) throws IOException {
        String uploadId = multipart.initUpload();
        return new InitUploadResp(uploadId);
    }

    @PutMapping(value = "/{uploadId}/chunk", consumes = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void chunk(@PathVariable String uploadId, @RequestBody byte[] body) throws IOException {
        multipart.appendChunk(uploadId, body);
    }

    @Transactional
    @PostMapping("/complete")
    public AudioFile complete(@RequestBody CompleteUploadReq req, Authentication auth) throws IOException {
        String userId = auth.getName();
        String finalKey = userId + "/" + req.uploadId() + ".m4a";
        String storageKey = multipart.finalizeUpload(req.uploadId(), finalKey);

        AudioFile af = new AudioFile();
        af.setOwnerUserId(userId);
        af.setFilename(req.uploadId() + ".m4a");
        af.setMimeType("audio/m4a");
        af.setSizeBytes(storage.size(storageKey));
        af.setStorageKey(storageKey);
        af.setDurationMs(req.durationMs());
        af.setSampleRate(req.sampleRate());
        af.setRequestId(null);
        return repo.save(af);
    }

    @GetMapping("/my")
    public List<AudioFile> my(Authentication auth) {
        return repo.findByOwnerUserIdOrderByCreatedAtDesc(auth.getName());
    }

    @DeleteMapping("/{id}")
    public void delete(@PathVariable UUID id, Authentication auth) throws IOException {
        AudioFile af = repo.findById(id).orElseThrow();
        if (!af.getOwnerUserId().equals(auth.getName())) throw new RuntimeException("Forbidden");
        storage.delete(af.getStorageKey());
        repo.delete(af);
    }

    @GetMapping("/{id}/stream")
    public void stream(@PathVariable UUID id, HttpServletRequest request, HttpServletResponse response, Authentication auth) throws IOException {
        AudioFile af = repo.findById(id).orElseThrow();
        if (!af.getOwnerUserId().equals(auth.getName())) throw new RuntimeException("Forbidden");

        long fileLength = storage.size(af.getStorageKey());
        String range = request.getHeader("Range");
        long start = 0, end = fileLength - 1;
        if (range != null && range.startsWith("bytes=")) {
            String[] parts = range.substring(6).split("-");
            start = Long.parseLong(parts[0]);
            if (parts.length > 1 && !parts[1].isEmpty()) end = Long.parseLong(parts[1]);
            if (end >= fileLength) end = fileLength - 1;
            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
        } else {
            response.setStatus(HttpServletResponse.SC_OK);
        }

        long contentLength = end - start + 1;
        response.setHeader("Accept-Ranges", "bytes");
        response.setHeader("Content-Type", af.getMimeType());
        response.setHeader("Content-Length", Long.toString(contentLength));
        if (range != null) response.setHeader("Content-Range", "bytes " + start + "-" + end + "/" + fileLength);

        try (InputStream in = storage.readRange(af.getStorageKey(), start, end)) {
            in.transferTo(response.getOutputStream());
        }
    }

    // -------- Phase 2: Direct-to-S3 MPU (presigned) --------
    @PostMapping("/mpu/create")
    public MpuCreateResp mpuCreate(@RequestBody MpuCreateReq req, Authentication auth) {
        String userId = auth.getName();
        String objectKey = userId + "/mpu/" + UUID.randomUUID() + "-" + req.filename();
        if (!(storage instanceof S3StorageService s3)) throw new IllegalStateException("MPU requires S3 storage");
        var res = s3.mpuCreate(objectKey, req.mimeType());
        return new MpuCreateResp(res.uploadId(), objectKey);
    }

    @PostMapping("/mpu/sign-part")
    public MpuSignedPart mpuSign(@RequestBody MpuSignPartReq req) {
        if (!(storage instanceof S3StorageService s3)) throw new IllegalStateException("MPU requires S3 storage");
        String url = s3.presignPartUrl(req.uploadId(), req.objectKey(), req.partNumber(), Duration.ofMinutes(15));
        return new MpuSignedPart(req.partNumber(), url);
    }

    @PostMapping("/mpu/complete")
    public void mpuComplete(@RequestBody MpuCompleteReq req) {
        if (!(storage instanceof S3StorageService s3)) throw new IllegalStateException("MPU requires S3 storage");
        s3.mpuComplete(req.uploadId(), req.objectKey(), req.parts());
    }

    @PostMapping("/mpu/abort")
    public void mpuAbort(@RequestBody MpuAbortReq req) {
        if (!(storage instanceof S3StorageService s3)) throw new IllegalStateException("MPU requires S3 storage");
        s3.mpuAbort(req.uploadId(), req.objectKey());
    }
}
===== END FILE: src/main/java/com/oolshik/backend/media/AudioController.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/MediaPresignController.java =====
// src/main/java/com/oolshik/backend/media/MediaPresignController.java
package com.oolshik.backend.media;

import org.springframework.web.bind.annotation.*;
import org.springframework.security.core.Authentication;

import java.time.Duration;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/media")
public class MediaPresignController {

    private final StorageService storage;

    public MediaPresignController(StorageService storage) {
        this.storage = storage;
    }

    public record PresignReq(String contentType) {}
    public record PresignResp(String uploadUrl, String fileUrl, String objectKey) {}

    @PostMapping("/pre-signed")
    public PresignResp create(@RequestBody PresignReq req, Authentication auth) {
        if (!(storage instanceof S3StorageService s3)) {
            // In local/dev mode we donâ€™t support presigned PUT. Frontend should fall back to chunked upload.
            throw new UnsupportedOperationException("Presigned uploads require media.storage=s3");
        }
        String userId = auth.getName();
        String ext = guessExt(req.contentType());
        String objectKey = userId + "/direct/" + UUID.randomUUID() + ext;
        String uploadUrl = s3.presignPutUrl(objectKey, req.contentType(), Duration.ofMinutes(15));
        String fileUrl = s3.toPublicUrl(objectKey);
        return new PresignResp(uploadUrl, fileUrl, objectKey);
    }

    private static String guessExt(String ct) {
        if (ct == null) return ".bin";
        String c = ct.toLowerCase();
        if (c.contains("audio/m4a") || c.contains("audio/aac")) return ".m4a";
        if (c.contains("audio/mp3") || c.contains("mpeg")) return ".mp3";
        if (c.contains("audio/ogg") || c.contains("opus")) return ".ogg";
        if (c.contains("wav")) return ".wav";
        return ".bin";
    }
}
===== END FILE: src/main/java/com/oolshik/backend/media/MediaPresignController.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/Dtos.java =====
package com.oolshik.backend.media;

public class Dtos {
    public record InitUploadReq(String filename, String mimeType, long size, String requestId) {}
    public record InitUploadResp(String uploadId) {}
    public record CompleteUploadReq(String uploadId, int totalChunks, Long durationMs, Integer sampleRate) {}

    // MPU (Phase 2)
    public record MpuCreateReq(String filename, String mimeType) {}
    public record MpuCreateResp(String uploadId, String objectKey) {}
    public record MpuSignPartReq(String uploadId, String objectKey, int partNumber) {}
    public record MpuSignedPart(int partNumber, String url) {}
    public record MpuCompleteReq(String uploadId, String objectKey, java.util.List<PartETag> parts) {}
    public record PartETag(int partNumber, String eTag) {}
    public record MpuAbortReq(String uploadId, String objectKey) {}
}
===== END FILE: src/main/java/com/oolshik/backend/media/Dtos.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/LocalStorageService.java =====
package com.oolshik.backend.media;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class LocalStorageService implements StorageService {

    private final Path root;

    public LocalStorageService(@Value("${media.local.root:./data/audio}") String rootDir) throws IOException {
        this.root = Paths.get(rootDir).toAbsolutePath();
        Files.createDirectories(this.root.resolve("tmp"));
        Files.createDirectories(this.root.resolve("store"));
    }

    @Override
    public String writeTemp(String uploadId) throws IOException {
        Path p = root.resolve("tmp").resolve(uploadId + ".part");
        Files.deleteIfExists(p);
        Files.createFile(p);
        return "tmp/" + uploadId + ".part";
    }

    @Override
    public void append(String tempKey, byte[] bytes) throws IOException {
        Path p = root.resolve(tempKey);
        try (OutputStream out = new BufferedOutputStream(new FileOutputStream(p.toFile(), true))) {
            out.write(bytes);
        }
    }

    @Override
    public String finalizeUpload(String tempKey, String finalKey) throws IOException {
        Path src = root.resolve(tempKey);
        Path dst = root.resolve("store").resolve(finalKey);
        Files.createDirectories(dst.getParent());
        Files.move(src, dst);
        return "store/" + finalKey;
    }

    @Override
    public InputStream readRange(String key, long start, long end) throws IOException {
        File f = root.resolve(key).toFile();
        RandomAccessFile raf = new RandomAccessFile(f, "r");
        raf.seek(start);
        long length = end - start + 1;
        InputStream is = new BufferedInputStream(new FileInputStream(raf.getFD())) {
            long remaining = length;
            @Override public int read() throws IOException {
                if (remaining <= 0) return -1;
                int b = super.read();
                if (b >= 0) remaining--;
                return b;
            }
            @Override public int read(byte[] b, int off, int len) throws IOException {
                if (remaining <= 0) return -1;
                len = (int)Math.min(len, remaining);
                int n = super.read(b, off, len);
                if (n > 0) remaining -= n;
                return n;
            }
        };
        return is;
    }

    @Override
    public long size(String key) throws IOException {
        return Files.size(root.resolve(key));
    }

    @Override
    public void delete(String key) throws IOException {
        Files.deleteIfExists(root.resolve(key));
    }
}
===== END FILE: src/main/java/com/oolshik/backend/media/LocalStorageService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/AudioFileRepository.java =====
package com.oolshik.backend.media;

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;
import java.util.UUID;

public interface AudioFileRepository extends JpaRepository<AudioFile, UUID> {
    List<AudioFile> findByOwnerUserIdOrderByCreatedAtDesc(String ownerUserId);
}
===== END FILE: src/main/java/com/oolshik/backend/media/AudioFileRepository.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/StorageService.java =====
package com.oolshik.backend.media;

import java.io.IOException;
import java.io.InputStream;

public interface StorageService {
    String writeTemp(String uploadId) throws IOException;
    void append(String tempKey, byte[] bytes) throws IOException;
    String finalizeUpload(String tempKey, String finalKey) throws IOException;
    InputStream readRange(String key, long start, long end) throws IOException;
    long size(String key) throws IOException;
    void delete(String key) throws IOException;
}
===== END FILE: src/main/java/com/oolshik/backend/media/StorageService.java =====


===== BEGIN FILE: src/main/java/com/oolshik/backend/media/AudioFile.java =====
package com.oolshik.backend.media;

import jakarta.persistence.*;
import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "audio_files")
public class AudioFile {
    @Id @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false) private String ownerUserId;
    @Column(nullable = false) private String filename;
    @Column(nullable = false) private String mimeType;
    @Column(nullable = false) private long sizeBytes;
    @Column(nullable = false) private String storageKey;
    @Column(nullable = false) private Instant createdAt = Instant.now();
    private Long durationMs;
    private Integer sampleRate;
    @Column private String requestId;

    public UUID getId() { return id; }
    public String getOwnerUserId() { return ownerUserId; }
    public void setOwnerUserId(String ownerUserId) { this.ownerUserId = ownerUserId; }
    public String getFilename() { return filename; }
    public void setFilename(String filename) { this.filename = filename; }
    public String getMimeType() { return mimeType; }
    public void setMimeType(String mimeType) { this.mimeType = mimeType; }
    public long getSizeBytes() { return sizeBytes; }
    public void setSizeBytes(long sizeBytes) { this.sizeBytes = sizeBytes; }
    public String getStorageKey() { return storageKey; }
    public void setStorageKey(String storageKey) { this.storageKey = storageKey; }
    public Instant getCreatedAt() { return createdAt; }
    public Long getDurationMs() { return durationMs; }
    public void setDurationMs(Long durationMs) { this.durationMs = durationMs; }
    public Integer getSampleRate() { return sampleRate; }
    public void setSampleRate(Integer sampleRate) { this.sampleRate = sampleRate; }
    public String getRequestId() { return requestId; }
    public void setRequestId(String requestId) { this.requestId = requestId; }
}
===== END FILE: src/main/java/com/oolshik/backend/media/AudioFile.java =====
